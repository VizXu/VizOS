diff --git a/Makefile b/Makefile
index ebce927..78287e3 100755
--- a/Makefile
+++ b/Makefile
@@ -1,131 +1,121 @@
-#
-# if you want the ram-disk device, define this to be the
-# size in blocks.
-#
-RAMDISK = #-DRAMDISK=512
-
-#AS86	=as86 -0 -a
-AS86	=as -a --32
-#LD86	=ld86 -0
-LD86	=ld
-
-AS	=gas
-LD	=gld
-LDFLAGS	=-s -x -M
-CC	=gcc $(RAMDISK)
-CFLAGS	=-Wall -O -fstrength-reduce -fomit-frame-pointer \
--fcombine-regs -mstring-insns
-CPP	=cpp -nostdinc -Iinclude
-
-#
-# ROOT_DEV specifies the default root-device when making the image.
-# This can be either FLOPPY, /dev/xxxx or empty, in which case the
-# default of /dev/hd6 is used by 'build'.
-#
-ROOT_DEV=/dev/hd6
-SWAP_DEV=/dev/hd2
-
-ARCHIVES=kernel/kernel.o mm/mm.o fs/fs.o
-DRIVERS =kernel/blk_drv/blk_drv.a kernel/chr_drv/chr_drv.a
-MATH	=kernel/math/math.a
-LIBS	=lib/lib.a
-
-.c.s:
-	$(CC) $(CFLAGS) \
-	-nostdinc -Iinclude -S -o $*.s $<
-.s.o:
-	$(AS) -c -o $*.o $<
-.c.o:
-	$(CC) $(CFLAGS) \
-	-nostdinc -Iinclude -c -o $*.o $<
-
-all:	Image
-
-Image: boot/bootsect boot/setup tools/system tools/build
-	tools/build boot/bootsect boot/setup tools/system $(ROOT_DEV) \
-		$(SWAP_DEV) > Image
-	sync
-
-disk: Image
-	dd bs=8192 if=Image of=/dev/PS0
-
-tools/build: tools/build.c
-	$(CC) $(CFLAGS) \
-	-o tools/build tools/build.c
-
-boot/head.o: boot/head.s
-
-tools/system:	boot/head.o init/main.o \
-		$(ARCHIVES) $(DRIVERS) $(MATH) $(LIBS)
-	$(LD) $(LDFLAGS) boot/head.o init/main.o \
-	$(ARCHIVES) \
-	$(DRIVERS) \
-	$(MATH) \
-	$(LIBS) \
-	-o tools/system > System.map
-
-kernel/math/math.a:
-	(cd kernel/math; make)
-
-kernel/blk_drv/blk_drv.a:
-	(cd kernel/blk_drv; make)
-
-kernel/chr_drv/chr_drv.a:
-	(cd kernel/chr_drv; make)
-
-kernel/kernel.o:
-	(cd kernel; make)
-
-mm/mm.o:
-	(cd mm; make)
-
-fs/fs.o:
-	(cd fs; make)
-
-lib/lib.a:
-	(cd lib; make)
-
-boot/setup: boot/setup.s
-	$(AS86) -o boot/setup.o boot/setup.s
-	$(LD86) -s -o boot/setup boot/setup.o
-
-boot/setup.s:	boot/setup.S include/viz/config.h
-	$(CPP) -traditional boot/setup.S -o boot/setup.s
-
-boot/bootsect.s:	boot/bootsect.S include/viz/config.h
-	$(CPP) -traditional boot/bootsect.S -o boot/bootsect.s
-
-boot/bootsect:	boot/bootsect.s
-	$(AS86) -o boot/bootsect.o boot/bootsect.s
-	$(LD86) -s -o boot/bootsect boot/bootsect.o
-
-clean:
-	rm -f Image System.map tmp_make core boot/bootsect boot/setup \
-		boot/bootsect.s boot/setup.s
-	rm -f init/*.o tools/system tools/build boot/*.o
-	(cd mm;make clean)
-	(cd fs;make clean)
-	(cd kernel;make clean)
-	(cd lib;make clean)
-
-backup: clean
-	(cd .. ; tar cf - viz | compress - > backup.Z)
-	sync
-
-dep:
-	sed '/\#\#\# Dependencies/q' < Makefile > tmp_make
-	(for i in init/*.c;do echo -n "init/";$(CPP) -M $$i;done) >> tmp_make
-	cp tmp_make Makefile
-	(cd fs; make dep)
-	(cd kernel; make dep)
-	(cd mm; make dep)
-
-### Dependencies:
-init/main.o : init/main.c include/unistd.h include/sys/stat.h \
-  include/sys/types.h include/sys/time.h include/time.h include/sys/times.h \
-  include/sys/utsname.h include/sys/param.h include/sys/resource.h \
-  include/utime.h include/viz/tty.h include/termios.h include/viz/sched.h \
-  include/viz/head.h include/viz/fs.h include/viz/mm.h \
-  include/viz/kernel.h include/signal.h include/asm/system.h \
-  include/asm/io.h include/stddef.h include/stdarg.h include/fcntl.h \
-  include/string.h 
+
+#
+# if you want the ram-disk device, define this to be the
+# size in blocks.
+#
+RAMDISK =  #-DRAMDISK=1024
+
+# This is a basic Makefile for setting the general configuration
+include Makefile.header
+
+LDFLAGS	+= -Ttext 0 -e startup_32
+CFLAGS	+= $(RAMDISK)
+CPP	+= -Iinclude
+
+#
+# ROOT_DEV specifies the default root-device when making the image.
+# This can be either FLOPPY, /dev/xxxx or empty, in which case the
+# default of /dev/hd6 is used by 'build'.
+#
+ROOT_DEV=0301
+SWAP_DEV=0304
+
+ARCHIVES=kernel/kernel.o mm/mm.o fs/fs.o
+DRIVERS =kernel/blk_drv/blk_drv.a kernel/chr_drv/chr_drv.a
+MATH	=kernel/math/math.a
+LIBS	=lib/lib.a
+
+.c.s:
+	$(CC) $(CFLAGS) \
+	-nostdinc -Iinclude -S -o $*.s $<
+.s.o:
+	$(AS) -o $*.o $<
+.c.o:
+	$(CC) $(CFLAGS) \
+	-nostdinc -Iinclude -c -o $*.o $<
+
+
+all: clean Image
+
+Image: boot/bootsect boot/setup tools/system
+	@cp -f tools/system system.tmp
+	@strip system.tmp
+	@objcopy -O binary -R .note -R .comment system.tmp tools/kernel
+	@tools/build.sh boot/bootsect boot/setup tools/kernel Kernel_Image $(ROOT_DEV) $(SWAP_DEV)
+	@rm system.tmp
+	@rm tools/kernel -f
+	@cp Kernel_Image ../viz-0.12-080324
+	@sync
+
+boot/bootsect: boot/bootsect.S
+	@make bootsect -C boot
+
+boot/setup: boot/setup.S
+	@make setup -C boot
+
+boot/head.o: boot/head.s
+	@make head.o -C boot
+
+tools/build: tools/build.c
+	$(CC) $(CFLAGS) \
+	-o tools/build tools/build.c
+
+tools/system:	boot/head.o init/main.o \
+		$(ARCHIVES) $(DRIVERS) $(MATH) $(LIBS)
+	$(LD) $(LDFLAGS) boot/head.o init/main.o \
+	$(ARCHIVES) \
+	$(DRIVERS) \
+	$(MATH) \
+	$(LIBS) \
+	-o tools/system
+	@nm tools/system | grep -v '\(compiled\)\|\(\.o$$\)\|\( [aU] \)\|\(\.\.ng$$\)\|\(LASH[RL]DI\)'| sort > System.map
+	@objdump -S tools/system > system.S
+
+kernel/math/math.a:
+	@make -C kernel/math
+
+fs/fs.o:
+	@make -C fs
+
+kernel/kernel.o:
+	@make -C kernel
+
+mm/mm.o:
+	@make -C mm
+
+lib/lib.a:
+	@make -C lib
+
+kernel/blk_drv/blk_drv.a:
+	@make -C kernel/blk_drv
+
+kernel/chr_drv/chr_drv.a:
+	@make -C kernel/chr_drv
+
+clean:
+	@rm -f Kernel_Image System.map System_s.map system.S tmp_make core boot/bootsect boot/setup
+	@rm -f init/*.o tools/system boot/*.o typescript* info bochsout.txt
+	@for i in mm fs kernel lib boot; do make clean -C $$i; done
+
+debug:
+	@qemu-system-i386 -m 32M -boot a -fda Image -fdb rootimage-0.12 -hda rootimage-0.12-hd \
+	-serial pty -S -gdb tcp::1234
+
+start:
+	@qemu-system-i386 -m 32M -boot a -fda Image -fdb rootimage-0.12 -hda rootimage-0.12-hd
+
+dep:
+	@sed '/\#\#\# Dependencies/q' < Makefile > tmp_make
+	@(for i in init/*.c;do echo -n "init/";$(CPP) -M $$i;done) >> tmp_make
+	@cp tmp_make Makefile
+	@for i in fs kernel mm lib; do make dep -C $$i; done
+
+### Dependencies:
+init/main.o: init/main.c include/unistd.h include/sys/stat.h \
+ include/sys/types.h include/sys/time.h include/time.h \
+ include/sys/times.h include/sys/utsname.h include/sys/param.h \
+ include/sys/resource.h include/utime.h include/viz/tty.h \
+ include/termios.h include/viz/sched.h include/viz/head.h \
+ include/viz/fs.h include/viz/mm.h include/viz/kernel.h \
+ include/signal.h include/asm/system.h include/asm/io.h include/stddef.h \
+ include/stdarg.h include/fcntl.h include/string.h
diff --git a/README.md b/README.md
index 907d212..ce7e993 100755
--- a/README.md
+++ b/README.md
@@ -1,2 +1,6 @@
 # VizOS
-A Small Unix like Operating System
+A Small Unix like Operating System, which is referring to the earlier Linux code and updated 
+
+according to other kernels.
+
+One should compile it on Ubuntu 16.04 and the GCC should be higher than 5.4.0
diff --git a/boot/bootsect.S b/boot/bootsect.S
index 51eeaea..7f0c30f 100755
--- a/boot/bootsect.S
+++ b/boot/bootsect.S
@@ -1,404 +1,449 @@
-#
-# SYS_SIZE is the number of clicks (16 bytes) to be loaded.
-# 0x3000 is 0x30000 bytes = 196kB, more than enough for current
-# versions of viz
-#
-#include <viz/config.h>
-SYSSIZE = DEF_SYSSIZE
-#
-#	bootsect.s		(C) 2019 VizXu
-#	modified by Drew Eckhardt
-#
-# bootsect.s is loaded at 0x7c00 by the bios-startup routines, and moves
-# iself out of the way to address 0x90000, and jumps there.
-#
-# It then loads 'setup' directly after itself (0x90200), and the system
-# at 0x10000, using BIOS interrupts. 
-#
-# NOTE# currently system is at most 8*65536 bytes long. This should be no
-# problem, even in the future. I want to keep it simple. This 512 kB
-# kernel size should be enough, especially as this doesn't contain the
-# buffer cache as in minix
-#
-# The loader has been made as simple as possible, and continuos
-# read errors will result in a unbreakable loop. Reboot by hand. It
-# loads pretty fast by getting whole sectors at a time whenever possible.
-
-.globl begtext, begdata, begbss, endtext, enddata, endbss
-.text
-begtext:
-.data
-begdata:
-.bss
-begbss:
-.text
-
-SETUPLEN = 4				# nr of setup-sectors
-BOOTSEG  = 0x07c0			# original address of boot-sector
-INITSEG  = DEF_INITSEG			# we move boot here - out of the way
-SETUPSEG = DEF_SETUPSEG			# setup starts here
-SYSSEG   = DEF_SYSSEG			# system loaded at 0x10000 (65536).
-ENDSEG   = SYSSEG + SYSSIZE		# where to stop loading
-
-# ROOT_DEV & SWAP_DEV are now written by "build".
-ROOT_DEV = 0
-SWAP_DEV = 0
-
-entry start
-start:
-	mov	ax,#BOOTSEG
-	mov	ds,ax
-	mov	ax,#INITSEG
-	mov	es,ax
-	mov	cx,#256
-	sub	si,si
-	sub	di,di
-	rep
-	movw
-	jmpi	go,INITSEG
-
-go:	mov	ax,cs		
-	mov	dx,#0xfef4	# arbitrary value >>512 - disk parm size
-
-	mov	ds,ax
-	mov	es,ax
-	push	ax
-
-	mov	ss,ax		# put stack at 0x9ff00 - 12.
-	mov	sp,dx
-/*
- *	Many BIOS's default disk parameter tables will not 
- *	recognize multi-sector reads beyond the maximum sector number
- *	specified in the default diskette parameter tables - this may
- *	mean 7 sectors in some cases.
- *
- *	Since single sector reads are slow and out of the question,
- *	we must take care of this by creating new parameter tables
- *	(for the first disk) in RAM.  We will set the maximum sector
- *	count to 18 - the most we will encounter on an HD 1.44.  
- *
- *	High doesn't hurt.  Low does.
- *
- *	Segments are as follows: ds=es=ss=cs - INITSEG,
- *		fs = 0, gs = parameter table segment
- */
-
-
-	push	#0
-	pop	fs
-	mov	bx,#0x78		# fs:bx is parameter table address
-	seg fs
-	lgs	si,(bx)			# gs:si is source
-
-	mov	di,dx			# es:di is destination
-	mov	cx,#6			# copy 12 bytes
-	cld
-
-	rep
-	seg gs
-	movw
-
-	mov	di,dx
-	movb	4(di),*18		# patch sector count
-
-	seg fs
-	mov	(bx),di
-	seg fs
-	mov	2(bx),es
-
-	pop	ax
-	mov	fs,ax
-	mov	gs,ax
-	
-	xor	ah,ah			# reset FDC 
-	xor	dl,dl
-	int 	0x13	
-
-# load the setup-sectors directly after the bootblock.
-# Note that 'es' is already set up.
-
-load_setup:
-	xor	dx, dx			# drive 0, head 0
-	mov	cx,#0x0002		# sector 2, track 0
-	mov	bx,#0x0200		# address = 512, in INITSEG
-	mov	ax,#0x0200+SETUPLEN	# service 2, nr of sectors
-	int	0x13			# read it
-	jnc	ok_load_setup		# ok - continue
-
-	push	ax			# dump error code
-	call	print_nl
-	mov	bp, sp
-	call	print_hex
-	pop	ax	
-	
-	xor	dl, dl			# reset FDC
-	xor	ah, ah
-	int	0x13
-	j	load_setup
-
-ok_load_setup:
-
-# Get disk drive parameters, specifically nr of sectors/track
-
-	xor	dl,dl
-	mov	ah,#0x08		# AH=8 is get drive parameters
-	int	0x13
-	xor	ch,ch
-	seg cs
-	mov	sectors,cx
-	mov	ax,#INITSEG
-	mov	es,ax
-
-# Print some inane message
-
-	mov	ah,#0x03		# read cursor pos
-	xor	bh,bh
-	int	0x10
-	
-	mov	cx,#9
-	mov	bx,#0x0007		# page 0, attribute 7 (normal)
-	mov	bp,#msg1
-	mov	ax,#0x1301		# write string, move cursor
-	int	0x10
-
-# ok, we've written the message, now
-# we want to load the system (at 0x10000)
-
-	mov	ax,#SYSSEG
-	mov	es,ax		# segment of 0x010000
-	call	read_it
-	call	kill_motor
-	call	print_nl
-
-# After that we check which root-device to use. If the device is
-# defined (#= 0), nothing is done and the given device is used.
-# Otherwise, either /dev/PS0 (2,28) or /dev/at0 (2,8), depending
-# on the number of sectors that the BIOS reports currently.
-
-	seg cs
-	mov	ax,root_dev
-	or	ax,ax
-	jne	root_defined
-	seg cs
-	mov	bx,sectors
-	mov	ax,#0x0208		# /dev/ps0 - 1.2Mb
-	cmp	bx,#15
-	je	root_defined
-	mov	ax,#0x021c		# /dev/PS0 - 1.44Mb
-	cmp	bx,#18
-	je	root_defined
-undef_root:
-	jmp undef_root
-root_defined:
-	seg cs
-	mov	root_dev,ax
-
-# after that (everyting loaded), we jump to
-# the setup-routine loaded directly after
-# the bootblock:
-
-	jmpi	0,SETUPSEG
-
-# This routine loads the system at address 0x10000, making sure
-# no 64kB boundaries are crossed. We try to load it as fast as
-# possible, loading whole tracks whenever we can.
-#
-# in:	es - starting address segment (normally 0x1000)
-#
-sread:	.word 1+SETUPLEN	# sectors read of current track
-head:	.word 0			# current head
-track:	.word 0			# current track
-
-read_it:
-	mov ax,es
-	test ax,#0x0fff
-die:	jne die			# es must be at 64kB boundary
-	xor bx,bx		# bx is starting address within segment
-rp_read:
-	mov ax,es
-	cmp ax,#ENDSEG		# have we loaded all yet?
-	jb ok1_read
-	ret
-ok1_read:
-	seg cs
-	mov ax,sectors
-	sub ax,sread
-	mov cx,ax
-	shl cx,#9
-	add cx,bx
-	jnc ok2_read
-	je ok2_read
-	xor ax,ax
-	sub ax,bx
-	shr ax,#9
-ok2_read:
-	call read_track
-	mov cx,ax
-	add ax,sread
-	seg cs
-	cmp ax,sectors
-	jne ok3_read
-	mov ax,#1
-	sub ax,head
-	jne ok4_read
-	inc track
-ok4_read:
-	mov head,ax
-	xor ax,ax
-ok3_read:
-	mov sread,ax
-	shl cx,#9
-	add bx,cx
-	jnc rp_read
-	mov ax,es
-	add ah,#0x10
-	mov es,ax
-	xor bx,bx
-	jmp rp_read
-
-read_track:
-	pusha
-	pusha	
-	mov	ax, #0xe2e 	# loading... message 2e = .
-	mov	bx, #7
- 	int	0x10
-	popa		
-
-	mov dx,track
-	mov cx,sread
-	inc cx
-	mov ch,dl
-	mov dx,head
-	mov dh,dl
-	and dx,#0x0100
-	mov ah,#2
-	
-	push	dx				# save for error dump
-	push	cx
-	push	bx
-	push	ax
-
-	int 0x13
-	jc bad_rt
-	add	sp, #8   	
-	popa
-	ret
-
-bad_rt:	push	ax				# save error code
-	call	print_all			# ah = error, al = read
-	
-	
-	xor ah,ah
-	xor dl,dl
-	int 0x13
-	
-
-	add	sp, #10
-	popa	
-	jmp read_track
-
-/*
- *	print_all is for debugging purposes.  
- *	It will print out all of the registers.  The assumption is that this is
- *	called from a routine, with a stack frame like
- *	dx 
- *	cx
- *	bx
- *	ax
- *	error
- *	ret <- sp
- *
-*/
- 
-print_all:
-	mov	cx, #5		# error code + 4 registers
-	mov	bp, sp	
-
-print_loop:
-	push	cx		# save count left
-	call	print_nl	# nl for readability
-	jae	no_reg		# see if register name is needed
-	
-	mov	ax, #0xe05 + 0x41 - 1
-	sub	al, cl
-	int	0x10
-
-	mov	al, #0x58 	# X
-	int	0x10
-
-	mov	al, #0x3a 	# :
-	int	0x10
-
-no_reg:
-	add	bp, #2		# next register
-	call	print_hex	# print it
-	pop	cx
-	loop	print_loop
-	ret
-
-print_nl:
-	mov	ax, #0xe0d	# CR
-	int	0x10
-	mov	al, #0xa	# LF
-	int 	0x10
-	ret
-
-/*
- *	print_hex is for debugging purposes, and prints the word
- *	pointed to by ss:bp in hexadecmial.
-*/
-
-print_hex:
-	mov	cx, #4		# 4 hex digits
-	mov	dx, (bp)	# load word into dx
-print_digit:
-	rol	dx, #4		# rotate so that lowest 4 bits are used
-	mov	ah, #0xe	
-	mov	al, dl		# mask off so we have only next nibble
-	and	al, #0xf
-	add	al, #0x30	# convert to 0 based digit, '0'
-	cmp	al, #0x39	# check for overflow
-	jbe	good_digit
-	add	al, #0x41 - 0x30 - 0xa 	# 'A' - '0' - 0xa
-
-good_digit:
-	int	0x10
-	loop	print_digit
-	ret
-
-
-/*
- * This procedure turns off the floppy drive motor, so
- * that we enter the kernel in a known state, and
- * don't have to worry about it later.
- */
-kill_motor:
-	push dx
-	mov dx,#0x3f2
-	xor al, al
-	outb
-	pop dx
-	ret
-
-sectors:
-	.word 0
-
-msg1:
-	.byte 13,10
-	.ascii "Loading"
-
-.org 506
-swap_dev:
-	.word SWAP_DEV
-root_dev:
-	.word ROOT_DEV
-boot_flag:
-	.word 0xAA55
-
-.text
-endtext:
-.data
-enddata:
-.bss
-endbss:
-
+!
+! SYS_SIZE is the number of clicks (16 bytes) to be loaded.
+! 0x3000 is 0x30000 bytes = 196kB, more than enough for current
+! versions of linux
+! 
+! 
+! 
+! 
+!
+! 
+! 
+! DEF_INITSEG	0x9000							
+! DEF_SYSSEG	0x1000							
+! DEF_SETUPSEG	0x9020							
+! DEF_SYSSIZE	0x3000							
+!
+#include <linux/config.h>
+SYSSIZE = DEF_SYSSIZE             				
+!
+!	bootsect.s		(C) 1991 Linus Torvalds
+!	modified by Drew Eckhardt
+!
+! bootsect.s is loaded at 0x7c00 by the bios-startup routines, and moves
+! iself out of the way to address 0x90000, and jumps there.
+!
+! It then loads 'setup' directly after itself (0x90200), and the system
+! at 0x10000, using BIOS interrupts.
+!
+! NOTE! currently system is at most 8*65536 bytes long. This should be no
+! problem, even in the future. I want to keep it simple. This 512 kB
+! kernel size should be enough, especially as this doesn't contain the
+! buffer cache as in minix
+!
+! The loader has been made as simple as possible, and continuos
+! read errors will result in a unbreakable loop. Reboot by hand. It
+! loads pretty fast by getting whole sectors at a time whenever possible.
+!
+!	bootsect.s		
+!	
+!
+! 
+! 
+!
+! 
+! 
+!
+.globl begtext, begdata, begbss, endtext, enddata, endbss
+.text
+begtext:
+.data
+begdata:
+.bss
+begbss:
+.text
+
+SETUPLEN = 4				! nr of setup-sectors
+							
+BOOTSEG  = 0x07c0			! original address of boot-sector
+							
+INITSEG  = DEF_INITSEG		! we move boot here - out of the way
+							
+SETUPSEG = DEF_SETUPSEG		! setup starts here
+							
+SYSSEG   = DEF_SYSSEG		! system loaded at 0x10000 (65536).
+							
+ENDSEG   = SYSSEG + SYSSIZE	! where to stop loading
+							
+
+! ROOT_DEV & SWAP_DEV are now written by "build".
+! 
+ROOT_DEV = 0				
+SWAP_DEV = 0				
+
+
+entry start					
+start:
+    mov	ax, #BOOTSEG		
+	mov	ds, ax
+	mov	ax, #INITSEG		
+	mov	es, ax
+	mov	cx, #256			
+	sub	si, si				
+	sub	di, di				
+	rep						
+	movw					
+	jmpi	go, INITSEG		
+							
+
+go:	mov	ax,cs
+	mov	dx, #0xfef4			! arbitrary value >>512 - disk parm size
+
+	mov	ds,ax
+	mov	es,ax
+
+	mov	ss,ax				! put stack at 0x9ff00 - 12.
+	mov	sp,dx
+/*
+ *	Many BIOS's default disk parameter tables will not
+ *	recognize multi-sector reads beyond the maximum sector number
+ *	specified in the default diskette parameter tables - this may
+ *	mean 7 sectors in some cases.
+ *
+ *	Since single sector reads are slow and out of the question,
+ *	we must take care of this by creating new parameter tables
+ *	(for the first disk) in RAM.  We will set the maximum sector
+ *	count to 18 - the most we will encounter on an HD 1.44.
+ *
+ *	High doesn't hurt.  Low does.
+ *
+ *	Segments are as follows: ds=es=ss=cs - INITSEG,
+ *		fs = 0, gs = parameter table segment
+ */
+	push	#0				
+	pop	fs				
+	mov	bx, #0x78			! fs:bx is parameter table address
+	
+	seg fs
+	lgs	si, (bx)			! gs:si is source
+
+	mov	di, dx				! es:di is destination  ! dx=0xfef4
+	mov	cx, #6				! copy 12 bytes
+	cld					
+
+	rep					
+	seg gs
+	movw
+
+	mov	di, dx			
+	movb 4(di), *18			! patch sector count
+
+	seg fs					
+	mov	(bx), di
+	seg fs
+	mov	2(bx), es
+
+	mov ax, cs			
+	mov	fs, ax
+	mov	gs, ax
+
+	xor	ah, ah				
+	xor	dl, dl			
+	int 0x13
+
+! load the setup-sectors directly after the bootblock.
+! Note that 'es' is already set up.
+load_setup:
+	xor	dx, dx						! drive 0, head 0
+	mov	cx, #0x0002					! sector 2, track 0
+	mov	bx, #0x0200					! address = 512, in INITSEG
+	mov	ax, #0x0200 + SETUPLEN		! service 2, nr of sectors
+	int	0x13						! read it
+	jnc	ok_load_setup				! ok - continue
+
+	push	ax						! dump error code
+	call	print_nl				
+	mov	bp, sp						
+	call print_hex					
+	pop	ax
+
+	xor	dl, dl						
+	xor	ah, ah
+	int	0x13
+	j	load_setup					
+
+ok_load_setup:
+
+! Get disk drive parameters, specifically nr of sectors/track
+
+
+
+	xor	dl, dl
+	mov	ah, #0x08					! AH=8 is get drive parameters
+	int	0x13
+	xor	ch, ch
+	seg cs
+	
+	mov	sectors, cx
+	mov	ax, #INITSEG
+	mov	es, ax						
+
+! Print some inane message
+
+	mov	ah, #0x03					! read cursor pos
+	xor	bh, bh						
+	int	0x10						! dh 行(0--24); dl 列(0--79).
+
+	mov	cx, #9						
+	mov	bx, #0x0007					! page 0, attribute 7 (normal)
+	mov	bp, #msg1					
+	mov	ax, #0x1301					! write string, move cursor
+	int	0x10						
+
+! ok, we've written the message, now
+! we want to load the system (at 0x10000)
+
+
+    mov ax, #SYSSEG
+    mov es, ax           			! segment of 0x010000  
+    call read_it         			
+    call kill_motor      			
+    call print_nl        			
+
+! After that we check which root-device to use. If the device is
+! defined (!= 0), nothing is done and the given device is used.
+! Otherwise, either /dev/PS0 (2,28) or /dev/at0 (2,8), depending
+! on the number of sectors that the BIOS reports currently.
+
+
+	seg cs
+	mov	ax, root_dev				
+	or	ax, ax
+	jne	root_defined
+	
+	seg cs
+	mov	bx, sectors
+	mov	ax, #0x0208					! /dev/ps0 - 1.2Mb
+	cmp	bx, #15
+	je	root_defined
+	mov	ax, #0x021c					! /dev/PS0 - 1.44Mb
+	cmp	bx, #18
+	je	root_defined
+undef_root:
+	jmp undef_root					
+root_defined:
+	seg cs
+	mov	root_dev, ax				
+
+! after that (everyting loaded), we jump to
+! the setup-routine loaded directly after
+! the bootblock:
+
+	jmpi	0, SETUPSEG				
+
+! This routine loads the system at address 0x10000, making sure
+! no 64kB boundaries are crossed. We try to load it as fast as
+! possible, loading whole tracks whenever we can.
+!
+! in:	es - starting address segment (normally 0x1000)
+!
+
+sread:	.word 1 + SETUPLEN				! sectors read of current track	
+head:	.word 0							! current head	
+track:	.word 0							! current track
+
+read_it:
+
+
+
+	mov ax, es
+	test ax, #0x0fff
+die:
+	jne die								! es must be at 64kB boundary	
+	xor bx, bx							! bx is starting address within segment
+rp_read:
+	mov ax, es
+	cmp ax, #ENDSEG						! have we loaded all yet?	
+	jb ok1_read
+	ret
+ok1_read:
+	seg cs
+	mov ax, sectors						
+	sub ax, sread						
+	mov cx, ax							
+	shl cx, #9							
+	add cx, bx
+	jnc ok2_read
+	je ok2_read
+	xor ax, ax
+	sub ax, bx
+	shr ax, #9
+ok2_read:
+	call read_track						
+	mov cx, ax							
+	add ax, sread						
+	seg cs
+	cmp ax, sectors						
+	jne ok3_read
+	mov ax, #1
+	sub ax, head						
+	jne ok4_read						
+	inc track						
+ok4_read:
+	mov head, ax						
+	xor ax, ax						
+ok3_read:
+	
+	mov sread, ax						
+	shl cx, #9						
+	add bx, cx						
+	jnc rp_read
+	mov ax, es
+	add ah, #0x10						
+	mov es, ax
+	xor bx, bx							
+	jmp rp_read							
+
+read_track:
+	pusha								
+	pusha								
+	mov	ax, #0xe2e 						! loading... message 2e = .
+	mov	bx, #7							
+ 	int	0x10
+	popa
+
+	mov dx, track						
+	mov cx, sread						
+	inc cx								
+	mov ch, dl						
+	mov dx, head					
+	mov dh, dl						
+	and dx, #0x0100						
+	mov ah, #2						
+
+	push	dx							! save for error dump
+	push	cx							
+	push	bx
+	push	ax
+
+	int 0x13
+	jc bad_rt							
+	add	sp, #8   						
+	popa
+	ret
+
+
+bad_rt:
+	push	ax							! save error code
+	call	print_all					! ah = error, al = read
+
+	xor ah, ah
+	xor dl, dl
+	int 0x13
+
+	add	sp, #10							
+	popa
+	jmp read_track
+
+/*
+ *	print_all is for debugging purposes.
+ *	It will print out all of the registers.  The assumption is that this is
+ *	called from a routine, with a stack frame like
+ *	dx
+ *	cx
+ *	bx
+ *	ax
+ *	error
+ *	ret <- sp
+ *
+*/
+
+
+
+print_all:
+	mov	cx, #5							! error code + 4 registers
+	mov	bp, sp							
+
+print_loop:
+	push	cx							! save count left	
+	call	print_nl					! nl for readability	
+	jae	no_reg							! see if register name is needed	
+
+	
+	mov	ax, #0xe05 + 0x41 - 1			
+	sub	al, cl
+	int	0x10
+
+	mov	al, #0x58 						! X		
+	int	0x10
+
+	mov	al, #0x3a 						! :		
+	int	0x10
+
+no_reg:
+	add	bp, #2							! next register	
+	call	print_hex					! print it	
+	pop	cx
+	loop	print_loop
+	ret
+
+
+print_nl:
+	mov	ax, #0xe0d						! CR
+	int	0x10
+	mov	al, #0xa						! LF
+	int 	0x10
+	ret
+
+/*
+ *	print_hex is for debugging purposes, and prints the word
+ *	pointed to by ss:bp in hexadecmial.
+*/
+
+print_hex:
+	mov	cx, #4							! 4 hex digits		
+	mov	dx, (bp)						! load word into dx	
+
+print_digit:
+	rol	dx, #4							! rotate so that lowest 4 bits are used
+	mov	ah, #0xe						
+	mov	al, dl							! mask off so we have only next nibble
+	and	al, #0xf						
+	add	al, #0x30						! convert to 0 based digit, '0'
+	cmp	al, #0x39						! check for overflow
+	jbe	good_digit
+	add	al, #0x41 - 0x30 - 0xa 			! 'A' - '0' - 0xa
+
+good_digit:
+	int	0x10
+	loop	print_digit					
+	ret
+
+
+/*
+ * This procedure turns off the floppy drive motor, so
+ * that we enter the kernel in a known state, and
+ * don't have to worry about it later.
+ */
+
+kill_motor:
+	push dx
+	mov dx, #0x3f2						
+	xor al, al						
+	outb							
+	pop dx
+	ret
+
+sectors:
+	.word 0							
+
+msg1:								
+	.byte 13,10						
+	.ascii "Loading"
+
+.org 506
+swap_dev:
+	.word SWAP_DEV						
+root_dev:
+	.word ROOT_DEV						
+boot_flag:
+	.word 0xAA55
+
+.text
+endtext:
+.data
+enddata:
+.bss
+endbss:
+
+
diff --git a/boot/head.s b/boot/head.s
index bae10f6..8a9f08f 100755
--- a/boot/head.s
+++ b/boot/head.s
@@ -1,238 +1,261 @@
-/*
- *  viz/boot/head.s
- *
- *  (C) VizXu 
- */
-
-/*
- *  head.s contains the 32-bit startup code.
- *
- * NOTE### Startup happens at absolute address 0x00000000, which is also where
- * the page directory will exist. The startup code will be overwritten by
- * the page directory.
- */
-.text
-.globl _idt,_gdt,_pg_dir,_tmp_floppy_area
-_pg_dir:
-startup_32:
-	movl $0x10,%eax
-	mov %ax,%ds
-	mov %ax,%es
-	mov %ax,%fs
-	mov %ax,%gs
-	lss _stack_start,%esp
-	call setup_idt
-	call setup_gdt
-	movl $0x10,%eax		# reload all the segment registers
-	mov %ax,%ds		# after changing gdt. CS was already
-	mov %ax,%es		# reloaded in 'setup_gdt'
-	mov %ax,%fs
-	mov %ax,%gs
-	lss _stack_start,%esp
-	xorl %eax,%eax
-1:	incl %eax		# check that A20 really IS enabled
-	movl %eax,0x000000	# loop forever if it isn't
-	cmpl %eax,0x100000
-	je 1b
-/*
- * NOTE# 486 should set bit 16, to check for write-protect in supervisor
- * mode. Then it would be unnecessary with the "verify_area()"-calls.
- * 486 users probably want to set the NE (#5) bit also, so as to use
- * int 16 for math errors.
- */
-	movl %cr0,%eax		# check math chip
-	andl $0x80000011,%eax	# Save PG,PE,ET
-/* "orl $0x10020,%eax" here for 486 might be good */
-	orl $2,%eax		# set MP
-	movl %eax,%cr0
-	call check_x87
-	jmp after_page_tables
-
-/*
- * We depend on ET to be correct. This checks for 287/387.
- */
-check_x87:
-	fninit
-	fstsw %ax
-	cmpb $0,%al
-	je 1f			/* no coprocessor: have to set bits */
-	movl %cr0,%eax
-	xorl $6,%eax		/* reset MP, set EM */
-	movl %eax,%cr0
-	ret
-.align 2
-1:	.byte 0xDB,0xE4		/* fsetpm for 287, ignored by 387 */
-	ret
-
-/*
- *  setup_idt
- *
- *  sets up a idt with 256 entries pointing to
- *  ignore_int, interrupt gates. It then loads
- *  idt. Everything that wants to install itself
- *  in the idt-table may do so themselves. Interrupts
- *  are enabled elsewhere, when we can be relatively
- *  sure everything is ok. This routine will be over-
- *  written by the page tables.
- */
-setup_idt:
-	lea ignore_int,%edx
-	movl $0x00080000,%eax
-	movw %dx,%ax		/* selector = 0x0008 = cs */
-	movw $0x8E00,%dx	/* interrupt gate - dpl=0, present */
-
-	lea _idt,%edi
-	mov $256,%ecx
-rp_sidt:
-	movl %eax,(%edi)
-	movl %edx,4(%edi)
-	addl $8,%edi
-	dec %ecx
-	jne rp_sidt
-	lidt idt_descr
-	ret
-
-/*
- *  setup_gdt
- *
- *  This routines sets up a new gdt and loads it.
- *  Only two entries are currently built, the same
- *  ones that were built in init.s. The routine
- *  is VERY complicated at two whole lines, so this
- *  rather long comment is certainly needed :-).
- *  This routine will beoverwritten by the page tables.
- */
-setup_gdt:
-	lgdt gdt_descr
-	ret
-
-/*
- * I put the kernel page tables right after the page directory,
- * using 4 of them to span 16 Mb of physical memory. People with
- * more than 16MB will have to expand this.
- */
-.org 0x1000
-pg0:
-
-.org 0x2000
-pg1:
-
-.org 0x3000
-pg2:
-
-.org 0x4000
-pg3:
-
-.org 0x5000
-/*
- * tmp_floppy_area is used by the floppy-driver when DMA cannot
- * reach to a buffer-block. It needs to be aligned, so that it isn't
- * on a 64kB border.
- */
-_tmp_floppy_area:
-	.fill 1024,1,0
-
-after_page_tables:
-	pushl $0		# These are the parameters to main :-)
-	pushl $0
-	pushl $0
-	pushl $L6		# return address for main, if it decides to.
-	pushl $_main
-	jmp setup_paging
-L6:
-	jmp L6			# main should never return here, but
-				# just in case, we know what happens.
-
-/* This is the default interrupt "handler" :-) */
-int_msg:
-	.asciz "Unknown interrupt\n\r"
-.align 2
-ignore_int:
-	pushl %eax
-	pushl %ecx
-	pushl %edx
-	push %ds
-	push %es
-	push %fs
-	movl $0x10,%eax
-	mov %ax,%ds
-	mov %ax,%es
-	mov %ax,%fs
-	pushl $int_msg
-	call _printk
-	popl %eax
-	pop %fs
-	pop %es
-	pop %ds
-	popl %edx
-	popl %ecx
-	popl %eax
-	iret
-
-
-/*
- * Setup_paging
- *
- * This routine sets up paging by setting the page bit
- * in cr0. The page tables are set up, identity-mapping
- * the first 16MB. The pager assumes that no illegal
- * addresses are produced (ie >4Mb on a 4Mb machine).
- *
- * NOTE# Although all physical memory should be identity
- * mapped by this routine, only the kernel page functions
- * use the >1Mb addresses directly. All "normal" functions
- * use just the lower 1Mb, or the local data space, which
- * will be mapped to some other place - mm keeps track of
- * that.
- *
- * For those with more memory than 16 Mb - tough luck. I've
- * not got it, why should you :-) The source is here. Change
- * it. (Seriously - it shouldn't be too difficult. Mostly
- * change some constants etc. I left it at 16Mb, as my machine
- * even cannot be extended past that (ok, but it was cheap :-)
- * I've tried to show which constants to change by having
- * some kind of marker at them (search for "16Mb"), but I
- * won't guarantee that's all :-( )
- */
-.align 2
-setup_paging:
-	movl $1024*5,%ecx		/* 5 pages - pg_dir+4 page tables */
-	xorl %eax,%eax
-	xorl %edi,%edi			/* pg_dir is at 0x000 */
-	cld;rep;stosl
-	movl $pg0+7,_pg_dir		/* set present bit/user r/w */
-	movl $pg1+7,_pg_dir+4		/*  --------- " " --------- */
-	movl $pg2+7,_pg_dir+8		/*  --------- " " --------- */
-	movl $pg3+7,_pg_dir+12		/*  --------- " " --------- */
-	movl $pg3+4092,%edi
-	movl $0xfff007,%eax		/*  16Mb - 4096 + 7 (r/w user,p) */
-	std
-1:	stosl			/* fill pages backwards - more efficient :-) */
-	subl $0x1000,%eax
-	jge 1b
-	xorl %eax,%eax		/* pg_dir is at 0x0000 */
-	movl %eax,%cr3		/* cr3 - page directory start */
-	movl %cr0,%eax
-	orl $0x80000000,%eax
-	movl %eax,%cr0		/* set paging (PG) bit */
-	ret			/* this also flushes prefetch-queue */
-
-.align 2
-.word 0
-idt_descr:
-	.word 256*8-1		# idt contains 256 entries
-	.long _idt
-.align 2
-.word 0
-gdt_descr:
-	.word 256*8-1		# so does gdt (not that that's any
-	.long _gdt		# magic number, but it works for me :^)
-
-	.align 3
-_idt:	.fill 256,8,0		# idt is uninitialized
-
-_gdt:	.quad 0x0000000000000000	/* NULL descriptor */
-	.quad 0x00c09a0000000fff	/* 16Mb */
-	.quad 0x00c0920000000fff	/* 16Mb */
-	.quad 0x0000000000000000	/* TEMPORARY - don't use */
-	.fill 252,8,0			/* space for LDT's and TSS's etc */
+/*
+ *  linux/boot/head.s
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
+ *  head.s contains the 32-bit startup code.
+ *
+ * NOTE!!! Startup happens at absolute address 0x00000000, which is also where
+ * the page directory will exist. The startup code will be overwritten by
+ * the page directory.
+ */
+
+.text
+.globl idt,gdt,pg_dir,tmp_floppy_area
+pg_dir:
+.globl startup_32
+startup_32:
+	movl $0x10, %eax					
+	mov %ax, %ds
+	mov %ax, %es
+	mov %ax, %fs
+	mov %ax, %gs
+	lss stack_start, %esp				
+	call setup_idt						
+	call setup_gdt						
+	movl $0x10, %eax					# reload all the segment registers
+	mov %ax, %ds						# after changing gdt. CS was already
+	mov %ax, %es						# reloaded in 'setup_gdt'
+	mov %ax, %fs						
+	mov %ax, %gs
+
+	lss stack_start, %esp
+
+	xorl %eax, %eax
+1:	incl %eax						# check that A20 really IS enabled
+	movl %eax, 0x000000					# loop forever if it isn't
+	cmpl %eax, 0x100000
+	je 1b							
+/*
+ * NOTE! 486 should set bit 16, to check for write-protect in supervisor
+ * mode. Then it would be unnecessary with the "verify_area()"-calls.
+ * 486 users probably want to set the NE (#5) bit also, so as to use
+ * int 16 for math errors.
+ */
+
+	movl %cr0, %eax						# check math chip
+	andl $0x80000011, %eax				# Save PG,PE,ET
+	/* "orl $0x10020,%eax" here for 486 might be good */
+	orl $2, %eax						# set MP
+	movl %eax, %cr0
+	call check_x87
+	jmp after_page_tables
+
+/*
+ * We depend on ET to be correct. This checks for 287/387.
+*/
+
+check_x87:
+	fninit								
+	fstsw %ax							
+	cmpb $0, %al						
+	je 1f								/* no coprocessor: have to set bits */
+	movl %cr0, %eax
+	xorl $6, %eax						/* reset MP, set EM */
+	movl %eax, %cr0
+	ret
+
+.align 2
+1:	.byte 0xDB,0xE4		/* fsetpm for 287, ignored by 387 */
+	ret
+
+/*
+ *  setup_idt
+ *
+ *  sets up a idt with 256 entries pointing to
+ *  ignore_int, interrupt gates. It then loads
+ *  idt. Everything that wants to install itself
+ *  in the idt-table may do so themselves. Interrupts
+ *  are enabled elsewhere, when we can be relatively
+ *  sure everything is ok. This routine will be over-
+ *  written by the page tables.
+ */
+
+setup_idt:
+	lea ignore_int, %edx			
+	movl $0x00080000, %eax			
+	movw %dx, %ax					/* selector = 0x0008 = cs */	
+	movw $0x8E00, %dx				/* interrupt gate - dpl=0, present */	
+
+	lea idt, %edi					
+	mov $256, %ecx
+rp_sidt:
+	movl %eax, (%edi)				
+	movl %edx, 4(%edi)
+	addl $8, %edi					
+	dec %ecx
+	jne rp_sidt
+	lidt idt_descr					
+	ret
+
+/*
+ *  setup_gdt
+ *
+ *  This routines sets up a new gdt and loads it.
+ *  Only two entries are currently built, the same
+ *  ones that were built in init.s. The routine
+ *  is VERY complicated at two whole lines, so this
+ *  rather long comment is certainly needed :-).
+ *  This routine will beoverwritten by the page tables.
+ */
+setup_gdt:
+	lgdt gdt_descr					
+	ret
+
+/*
+ * I put the kernel page tables right after the page directory,
+ * using 4 of them to span 16 Mb of physical memory. People with
+ * more than 16MB will have to expand this.
+ */
+
+.org 0x1000							
+pg0:
+
+.org 0x2000
+pg1:
+
+.org 0x3000
+pg2:
+
+.org 0x4000
+pg3:
+
+.org 0x5000							
+/*
+ * tmp_floppy_area is used by the floppy-driver when DMA cannot
+ * reach to a buffer-block. It needs to be aligned, so that it isn't
+ * on a 64kB border.
+ */
+
+tmp_floppy_area:
+	.fill 1024,1,0					
+
+after_page_tables:
+	pushl $0						# These are the parameters to main :-)
+	pushl $0						
+	pushl $0						
+	pushl $L6						# return address for main, if it decides to.
+	pushl $main					
+	jmp setup_paging				
+L6:
+	jmp L6							# main should never return here, but
+									# just in case, we know what happens.
+									
+
+/* This is the default interrupt "handler" :-) */
+
+int_msg:
+	.asciz "Unknown interrupt\n\r"
+
+.align 2						
+ignore_int:
+	pushl %eax
+	pushl %ecx
+	pushl %edx
+	push %ds						
+	push %es
+	push %fs
+	movl $0x10, %eax			
+	mov %ax, %ds
+	mov %ax, %es
+	mov %ax, %fs
+	pushl $int_msg					
+	call printk						
+	popl %eax
+	pop %fs
+	pop %es
+	pop %ds
+	popl %edx
+	popl %ecx
+	popl %eax
+	iret							
+
+
+/*
+ * Setup_paging
+ *
+ * This routine sets up paging by setting the page bit
+ * in cr0. The page tables are set up, identity-mapping
+ * the first 16MB. The pager assumes that no illegal
+ * addresses are produced (ie >4Mb on a 4Mb machine).
+ *
+ * NOTE! Although all physical memory should be identity
+ * mapped by this routine, only the kernel page functions
+ * use the >1Mb addresses directly. All "normal" functions
+ * use just the lower 1Mb, or the local data space, which
+ * will be mapped to some other place - mm keeps track of
+ * that.
+ *
+ * For those with more memory than 16 Mb - tough luck. I've
+ * not got it, why should you :-) The source is here. Change
+ * it. (Seriously - it shouldn't be too difficult. Mostly
+ * change some constants etc. I left it at 16Mb, as my machine
+ * even cannot be extended past that (ok, but it was cheap :-)
+ * I've tried to show which constants to change by having
+ * some kind of marker at them (search for "16Mb"), but I
+ * won't guarantee that's all :-( )
+ */
+
+.align 2							
+setup_paging:						
+	movl $1024 * 5, %ecx				/* 5 pages - pg_dir+4 page tables */
+	xorl %eax, %eax
+	xorl %edi, %edi						/* pg_dir is at 0x000 */	
+	cld;rep;stosl						
+
+	movl $pg0 + 7, pg_dir				/* set present bit/user r/w */
+	movl $pg1 + 7, pg_dir + 4			/*  --------- " " --------- */
+	movl $pg2 + 7, pg_dir + 8			/*  --------- " " --------- */
+	movl $pg3 + 7, pg_dir + 12			/*  --------- " " --------- */
+
+	movl $pg3 + 4092, %edi			
+	movl $0xfff007, %eax				/*  16Mb - 4096 + 7 (r/w user,p) */
+										
+	std									
+1:	stosl								/* fill pages backwards - more efficient :-) */
+	subl $0x1000, %eax				
+	jge 1b							
+	cld
+	xorl %eax, %eax						/* pg_dir is at 0x0000 */		# 页目录表在0x0000处.
+	movl %eax, %cr3						/* cr3 - page directory start */
+	movl %cr0, %eax
+	orl $0x80000000, %eax				
+	movl %eax, %cr0						/* set paging (PG) bit */
+	ret									/* this also flushes prefetch-queue */
+
+.align 2								
+.word 0									
+
+idt_descr:
+	.word 256 * 8 - 1					# idt contains 256 entries
+	.long idt
+.align 2
+.word 0
+
+
+gdt_descr:
+	.word 256 * 8 - 1					# so does gdt (not that that's any
+	.long gdt							# magic number, but it works for me :^)
+
+	.align 8							
+idt:	.fill 256, 8, 0					# idt is uninitialized	
+
+ # (0-nul, 1-cs, 2-ds, 3-syscall, 4-TSS0, 5-LDT0, 6-TSS1, 7-LDT1, 8-TSS2 etc...)
+gdt:
+	.quad 0x0000000000000000			/* NULL descriptor */
+	.quad 0x00c09a0000000fff			/* 16Mb */		
+	.quad 0x00c0920000000fff			/* 16Mb */		
+	.quad 0x0000000000000000			/* TEMPORARY - don't use */
+	.fill 252, 8, 0						/* space for LDT's and TSS's etc */
diff --git a/boot/setup.S b/boot/setup.S
index 97d87a2..e69cd88 100755
--- a/boot/setup.S
+++ b/boot/setup.S
@@ -1,631 +1,662 @@
-#
-#	setup.s		(C) 2019 VizXu
-#
-# setup.s is responsible for getting the system data from the BIOS,
-# and putting them into the appropriate places in system memory.
-# both setup.s and system has been loaded by the bootblock.
-#
-# This code asks the bios for memory/disk/other parameters, and
-# puts them in a "safe" place: 0x90000-0x901FF, ie where the
-# boot-block used to be. It is then up to the protected mode
-# system to read them from there before the area is overwritten
-# for buffer-blocks.
-#
-
-# NOTE# These had better be the same as in bootsect.s#
-#include <viz/config.h>
-
-INITSEG  = DEF_INITSEG	# we move boot here - out of the way
-SYSSEG   = DEF_SYSSEG	# system loaded at 0x10000 (65536).
-SETUPSEG = DEF_SETUPSEG	# this is the current segment
-
-.globl begtext, begdata, begbss, endtext, enddata, endbss
-.text
-begtext:
-.data
-begdata:
-.bss
-begbss:
-.text
-
-entry start
-start:
-
-# ok, the read went well so we get current cursor position and save it for
-# posterity.
-
-	mov	ax,#INITSEG	# this is done in bootsect already, but...
-	mov	ds,ax
-
-# Get memory size (extended mem, kB)
-
-	mov	ah,#0x88
-	int	0x15
-	mov	[2],ax
-
-# check for EGA/VGA and some config parameters
-
-	mov	ah,#0x12
-	mov	bl,#0x10
-	int	0x10
-	mov	[8],ax
-	mov	[10],bx
-	mov	[12],cx
-	mov	ax,#0x5019
-	cmp	bl,#0x10
-	je	novga
-	call	chsvga
-novga:	mov	[14],ax
-	mov	ah,#0x03	# read cursor pos
-	xor	bh,bh
-	int	0x10		# save it in known place, con_init fetches
-	mov	[0],dx		# it from 0x90000.
-	
-# Get video-card data:
-	
-	mov	ah,#0x0f
-	int	0x10
-	mov	[4],bx		# bh = display page
-	mov	[6],ax		# al = video mode, ah = window width
-
-# Get hd0 data
-
-	mov	ax,#0x0000
-	mov	ds,ax
-	lds	si,[4*0x41]
-	mov	ax,#INITSEG
-	mov	es,ax
-	mov	di,#0x0080
-	mov	cx,#0x10
-	rep
-	movsb
-
-# Get hd1 data
-
-	mov	ax,#0x0000
-	mov	ds,ax
-	lds	si,[4*0x46]
-	mov	ax,#INITSEG
-	mov	es,ax
-	mov	di,#0x0090
-	mov	cx,#0x10
-	rep
-	movsb
-
-# Check that there IS a hd1 :-)
-
-	mov	ax,#0x01500
-	mov	dl,#0x81
-	int	0x13
-	jc	no_disk1
-	cmp	ah,#3
-	je	is_disk1
-no_disk1:
-	mov	ax,#INITSEG
-	mov	es,ax
-	mov	di,#0x0090
-	mov	cx,#0x10
-	mov	ax,#0x00
-	rep
-	stosb
-is_disk1:
-
-# now we want to move to protected mode ...
-
-	cli			# no interrupts allowed #
-
-# first we move the system to it's rightful place
-
-	mov	ax,#0x0000
-	cld			# 'direction'=0, movs moves forward
-do_move:
-	mov	es,ax		# destination segment
-	add	ax,#0x1000
-	cmp	ax,#0x9000
-	jz	end_move
-	mov	ds,ax		# source segment
-	sub	di,di
-	sub	si,si
-	mov 	cx,#0x8000
-	rep
-	movsw
-	jmp	do_move
-
-# then we load the segment descriptors
-
-end_move:
-	mov	ax,#SETUPSEG	# right, forgot this at first. didn't work :-)
-	mov	ds,ax
-	lidt	idt_48		# load idt with 0,0
-	lgdt	gdt_48		# load gdt with whatever appropriate
-
-# that was painless, now we enable A20
-
-	call	empty_8042
-	mov	al,#0xD1		# command write
-	out	#0x64,al
-	call	empty_8042
-	mov	al,#0xDF		# A20 on
-	out	#0x60,al
-	call	empty_8042
-
-# well, that went ok, I hope. Now we have to reprogram the interrupts :-(
-# we put them right after the intel-reserved hardware interrupts, at
-# int 0x20-0x2F. There they won't mess up anything. Sadly IBM really
-# messed this up with the original PC, and they haven't been able to
-# rectify it afterwards. Thus the bios puts interrupts at 0x08-0x0f,
-# which is used for the internal hardware interrupts as well. We just
-# have to reprogram the 8259's, and it isn't fun.
-
-	mov	al,#0x11		# initialization sequence
-	out	#0x20,al		# send it to 8259A-1
-	.word	0x00eb,0x00eb		# jmp $+2, jmp $+2
-	out	#0xA0,al		# and to 8259A-2
-	.word	0x00eb,0x00eb
-	mov	al,#0x20		# start of hardware int's (0x20)
-	out	#0x21,al
-	.word	0x00eb,0x00eb
-	mov	al,#0x28		# start of hardware int's 2 (0x28)
-	out	#0xA1,al
-	.word	0x00eb,0x00eb
-	mov	al,#0x04		# 8259-1 is master
-	out	#0x21,al
-	.word	0x00eb,0x00eb
-	mov	al,#0x02		# 8259-2 is slave
-	out	#0xA1,al
-	.word	0x00eb,0x00eb
-	mov	al,#0x01		# 8086 mode for both
-	out	#0x21,al
-	.word	0x00eb,0x00eb
-	out	#0xA1,al
-	.word	0x00eb,0x00eb
-	mov	al,#0xFF		# mask off all interrupts for now
-	out	#0x21,al
-	.word	0x00eb,0x00eb
-	out	#0xA1,al
-
-# well, that certainly wasn't fun :-(. Hopefully it works, and we don't
-# need no steenking BIOS anyway (except for the initial loading :-).
-# The BIOS-routine wants lots of unnecessary data, and it's less
-# "interesting" anyway. This is how REAL programmers do it.
-#
-# Well, now's the time to actually move into protected mode. To make
-# things as simple as possible, we do no register set-up or anything,
-# we let the gnu-compiled 32-bit programs do that. We just jump to
-# absolute address 0x00000, in 32-bit protected mode.
-
-	mov	ax,#0x0001	# protected mode (PE) bit
-	lmsw	ax		# This is it#
-	jmpi	0,8		# jmp offset 0 of segment 8 (cs)
-
-# This routine checks that the keyboard command queue is empty
-# No timeout is used - if this hangs there is something wrong with
-# the machine, and we probably couldn't proceed anyway.
-empty_8042:
-	.word	0x00eb,0x00eb
-	in	al,#0x64	# 8042 status port
-	test	al,#2		# is input buffer full?
-	jnz	empty_8042	# yes - loop
-	ret
-
-# Routine trying to recognize type of SVGA-board present (if any)
-# and if it recognize one gives the choices of resolution it offers.
-# If one is found the resolution chosen is given by al,ah (rows,cols).
-
-chsvga:	cld
-	push	ds
-	push	cs
-	pop	ds
-	mov 	ax,#0xc000
-	mov	es,ax
-	lea	si,msg1
-	call	prtstr
-nokey:	in	al,#0x60
-	cmp	al,#0x82
-	jb	nokey
-	cmp	al,#0xe0
-	ja	nokey
-	cmp	al,#0x9c
-	je	svga
-	mov	ax,#0x5019
-	pop	ds
-	ret
-svga:	lea 	si,idati		# Check ATI 'clues'
-	mov	di,#0x31
-	mov 	cx,#0x09
-	repe
-	cmpsb
-	jne	noati
-	lea	si,dscati
-	lea	di,moati
-	lea	cx,selmod
-	jmp	cx
-noati:	mov	ax,#0x200f		# Check Ahead 'clues'
-	mov	dx,#0x3ce
-	out	dx,ax
-	inc	dx
-	in	al,dx
-	cmp	al,#0x20
-	je	isahed
-	cmp	al,#0x21
-	jne	noahed
-isahed:	lea	si,dscahead
-	lea	di,moahead
-	lea	cx,selmod
-	jmp	cx
-noahed:	mov	dx,#0x3c3		# Check Chips & Tech. 'clues'
-	in	al,dx
-	or	al,#0x10
-	out	dx,al
-	mov	dx,#0x104		
-	in	al,dx
-	mov	bl,al
-	mov	dx,#0x3c3
-	in	al,dx
-	and	al,#0xef
-	out	dx,al
-	cmp	bl,[idcandt]
-	jne	nocant
-	lea	si,dsccandt
-	lea	di,mocandt
-	lea	cx,selmod
-	jmp	cx
-nocant:	mov	dx,#0x3d4		# Check Cirrus 'clues'
-	mov	al,#0x0c
-	out	dx,al
-	inc	dx
-	in	al,dx
-	mov	bl,al
-	xor	al,al
-	out	dx,al
-	dec	dx
-	mov	al,#0x1f
-	out	dx,al
-	inc	dx
-	in	al,dx
-	mov	bh,al
-	xor	ah,ah
-	shl	al,#4
-	mov	cx,ax
-	mov	al,bh
-	shr	al,#4
-	add	cx,ax
-	shl	cx,#8
-	add	cx,#6
-	mov	ax,cx
-	mov	dx,#0x3c4
-	out	dx,ax
-	inc	dx
-	in	al,dx
-	and	al,al
-	jnz	nocirr
-	mov	al,bh
-	out	dx,al
-	in	al,dx
-	cmp	al,#0x01
-	jne	nocirr
-	call	rst3d4	
-	lea	si,dsccirrus
-	lea	di,mocirrus
-	lea	cx,selmod
-	jmp	cx
-rst3d4:	mov	dx,#0x3d4
-	mov	al,bl
-	xor	ah,ah
-	shl	ax,#8
-	add	ax,#0x0c
-	out	dx,ax
-	ret	
-nocirr:	call	rst3d4			# Check Everex 'clues'
-	mov	ax,#0x7000
-	xor	bx,bx
-	int	0x10
-	cmp	al,#0x70
-	jne	noevrx
-	shr	dx,#4
-	cmp	dx,#0x678
-	je	istrid
-	cmp	dx,#0x236
-	je	istrid
-	lea	si,dsceverex
-	lea	di,moeverex
-	lea	cx,selmod
-	jmp	cx
-istrid:	lea	cx,ev2tri
-	jmp	cx
-noevrx:	lea	si,idgenoa		# Check Genoa 'clues'
-	xor 	ax,ax
-	seg es
-	mov	al,[0x37]
-	mov	di,ax
-	mov	cx,#0x04
-	dec	si
-	dec	di
-l1:	inc	si
-	inc	di
-	mov	al,(si)
-	seg es
-	and	al,(di)
-	cmp	al,(si)
-	loope 	l1
-	cmp	cx,#0x00
-	jne	nogen
-	lea	si,dscgenoa
-	lea	di,mogenoa
-	lea	cx,selmod
-	jmp	cx
-nogen:	lea	si,idparadise		# Check Paradise 'clues'
-	mov	di,#0x7d
-	mov	cx,#0x04
-	repe
-	cmpsb
-	jne	nopara
-	lea	si,dscparadise
-	lea	di,moparadise
-	lea	cx,selmod
-	jmp	cx
-nopara:	mov	dx,#0x3c4		# Check Trident 'clues'
-	mov	al,#0x0e
-	out	dx,al
-	inc	dx
-	in	al,dx
-	xchg	ah,al
-	mov	al,#0x00
-	out	dx,al
-	in	al,dx
-	xchg	al,ah
-	mov	bl,al		# Strange thing ... in the book this wasn't
-	and	bl,#0x02	# necessary but it worked on my card which
-	jz	setb2		# is a trident. Without it the screen goes
-	and	al,#0xfd	# blurred ...
-	jmp	clrb2		#
-setb2:	or	al,#0x02	#
-clrb2:	out	dx,al
-	and	ah,#0x0f
-	cmp	ah,#0x02
-	jne	notrid
-ev2tri:	lea	si,dsctrident
-	lea	di,motrident
-	lea	cx,selmod
-	jmp	cx
-notrid:	mov	dx,#0x3cd		# Check Tseng 'clues'
-	in	al,dx			# Could things be this simple # :-)
-	mov	bl,al
-	mov	al,#0x55
-	out	dx,al
-	in	al,dx
-	mov	ah,al
-	mov	al,bl
-	out	dx,al
-	cmp	ah,#0x55
- 	jne	notsen
-	lea	si,dsctseng
-	lea	di,motseng
-	lea	cx,selmod
-	jmp	cx
-notsen:	mov	dx,#0x3cc		# Check Video7 'clues'
-	in	al,dx
-	mov	dx,#0x3b4
-	and	al,#0x01
-	jz	even7
-	mov	dx,#0x3d4
-even7:	mov	al,#0x0c
-	out	dx,al
-	inc	dx
-	in	al,dx
-	mov	bl,al
-	mov	al,#0x55
-	out	dx,al
-	in	al,dx
-	dec	dx
-	mov	al,#0x1f
-	out	dx,al
-	inc	dx
-	in	al,dx
-	mov	bh,al
-	dec	dx
-	mov	al,#0x0c
-	out	dx,al
-	inc	dx
-	mov	al,bl
-	out	dx,al
-	mov	al,#0x55
-	xor	al,#0xea
-	cmp	al,bh
-	jne	novid7
-	lea	si,dscvideo7
-	lea	di,movideo7
-selmod:	push	si
-	lea	si,msg2
-	call	prtstr
-	xor	cx,cx
-	mov	cl,(di)
-	pop	si
-	push	si
-	push	cx
-tbl:	pop	bx
-	push	bx
-	mov	al,bl
-	sub	al,cl
-	call	dprnt
-	call	spcing
-	lodsw
-	xchg	al,ah
-	call	dprnt
-	xchg	ah,al
-	push	ax
-	mov	al,#0x78
-	call	prnt1
-	pop	ax
-	call	dprnt
-	call	docr
-	loop	tbl
-	pop	cx
-	call	docr
-	lea	si,msg3
-	call	prtstr
-	pop	si
-	add	cl,#0x80
-nonum:	in	al,#0x60	# Quick and dirty...
-	cmp	al,#0x82
-	jb	nonum
-	cmp	al,#0x8b
-	je	zero
-	cmp	al,cl
-	ja	nonum
-	jmp	nozero
-zero:	sub	al,#0x0a
-nozero:	sub	al,#0x80
-	dec	al
-	xor	ah,ah
-	add	di,ax
-	inc	di
-	push	ax
-	mov	al,(di)
-	int 	0x10
-	pop	ax
-	shl	ax,#1
-	add	si,ax
-	lodsw
-	pop	ds
-	ret
-novid7:	pop	ds	# Here could be code to support standard 80x50,80x30
-	mov	ax,#0x5019	
-	ret
-
-# Routine that 'tabs' to next col.
-
-spcing:	mov	al,#0x2e
-	call	prnt1
-	mov	al,#0x20
-	call	prnt1	
-	mov	al,#0x20
-	call	prnt1	
-	mov	al,#0x20
-	call	prnt1	
-	mov	al,#0x20
-	call	prnt1
-	ret	
-
-# Routine to print asciiz-string at DS:SI
-
-prtstr:	lodsb
-	and	al,al
-	jz	fin
-	call	prnt1
-	jmp	prtstr
-fin:	ret
-
-# Routine to print a decimal value on screen, the value to be
-# printed is put in al (i.e 0-255). 
-
-dprnt:	push	ax
-	push	cx
-	mov	ah,#0x00		
-	mov	cl,#0x0a
-	idiv	cl
-	cmp	al,#0x09
-	jbe	lt100
-	call	dprnt
-	jmp	skip10
-lt100:	add	al,#0x30
-	call	prnt1
-skip10:	mov	al,ah
-	add	al,#0x30
-	call	prnt1	
-	pop	cx
-	pop	ax
-	ret
-
-# Part of above routine, this one just prints ascii al
-
-prnt1:	push	ax
-	push	cx
-	mov	bh,#0x00
-	mov	cx,#0x01
-	mov	ah,#0x0e
-	int	0x10
-	pop	cx
-	pop	ax
-	ret
-
-# Prints <CR> + <LF>
-
-docr:	push	ax
-	push	cx
-	mov	bh,#0x00
-	mov	ah,#0x0e
-	mov	al,#0x0a
-	mov	cx,#0x01
-	int	0x10
-	mov	al,#0x0d
-	int	0x10
-	pop	cx
-	pop	ax
-	ret	
-	
-gdt:
-	.word	0,0,0,0		# dummy
-
-	.word	0x07FF		# 8Mb - limit=2047 (2048*4096=8Mb)
-	.word	0x0000		# base address=0
-	.word	0x9A00		# code read/exec
-	.word	0x00C0		# granularity=4096, 386
-
-	.word	0x07FF		# 8Mb - limit=2047 (2048*4096=8Mb)
-	.word	0x0000		# base address=0
-	.word	0x9200		# data read/write
-	.word	0x00C0		# granularity=4096, 386
-
-idt_48:
-	.word	0			# idt limit=0
-	.word	0,0			# idt base=0L
-
-gdt_48:
-	.word	0x800		# gdt limit=2048, 256 GDT entries
-	.word	512+gdt,0x9	# gdt base = 0X9xxxx
-
-msg1:		.ascii	"Press <RETURN> to see SVGA-modes available or any other key to continue."
-		db	0x0d, 0x0a, 0x0a, 0x00
-msg2:		.ascii	"Mode:  COLSxROWS:"
-		db	0x0d, 0x0a, 0x0a, 0x00
-msg3:		.ascii	"Choose mode by pressing the corresponding number."
-		db	0x0d, 0x0a, 0x00
-		
-idati:		.ascii	"761295520"
-idcandt:	.byte	0xa5
-idgenoa:	.byte	0x77, 0x00, 0x66, 0x99
-idparadise:	.ascii	"VGA="
-
-# Manufacturer:	  Numofmodes:	Mode:
-
-moati:		.byte	0x02,	0x23, 0x33 
-moahead:	.byte	0x05,	0x22, 0x23, 0x24, 0x2f, 0x34
-mocandt:	.byte	0x02,	0x60, 0x61
-mocirrus:	.byte	0x04,	0x1f, 0x20, 0x22, 0x31
-moeverex:	.byte	0x0a,	0x03, 0x04, 0x07, 0x08, 0x0a, 0x0b, 0x16, 0x18, 0x21, 0x40
-mogenoa:	.byte	0x0a,	0x58, 0x5a, 0x60, 0x61, 0x62, 0x63, 0x64, 0x72, 0x74, 0x78
-moparadise:	.byte	0x02,	0x55, 0x54
-motrident:	.byte	0x07,	0x50, 0x51, 0x52, 0x57, 0x58, 0x59, 0x5a
-motseng:	.byte	0x05,	0x26, 0x2a, 0x23, 0x24, 0x22
-movideo7:	.byte	0x06,	0x40, 0x43, 0x44, 0x41, 0x42, 0x45
-
-#			msb = Cols lsb = Rows:
-
-dscati:		.word	0x8419, 0x842c
-dscahead:	.word	0x842c, 0x8419, 0x841c, 0xa032, 0x5042
-dsccandt:	.word	0x8419, 0x8432
-dsccirrus:	.word	0x8419, 0x842c, 0x841e, 0x6425
-dsceverex:	.word	0x5022, 0x503c, 0x642b, 0x644b, 0x8419, 0x842c, 0x501e, 0x641b, 0xa040, 0x841e
-dscgenoa:	.word	0x5020, 0x642a, 0x8419, 0x841d, 0x8420, 0x842c, 0x843c, 0x503c, 0x5042, 0x644b
-dscparadise:	.word	0x8419, 0x842b
-dsctrident:	.word 	0x501e, 0x502b, 0x503c, 0x8419, 0x841e, 0x842b, 0x843c
-dsctseng:	.word	0x503c, 0x6428, 0x8419, 0x841c, 0x842c
-dscvideo7:	.word	0x502b, 0x503c, 0x643c, 0x8419, 0x842c, 0x841c
-	
-.text
-endtext:
-.data
-enddata:
-.bss
-endbss:
+!
+!	setup.s		(C) 1991 Linus Torvalds
+!
+! setup.s is responsible for getting the system data from the BIOS,
+! and putting them into the appropriate places in system memory.
+! both setup.s and system has been loaded by the bootblock.
+!
+! This code asks the bios for memory/disk/other parameters, and
+! puts them in a "safe" place: 0x90000-0x901FF, ie where the
+! boot-block used to be. It is then up to the protected mode
+! system to read them from there before the area is overwritten
+! for buffer-blocks.
+!
+
+! NOTE! These had better be the same as in bootsect.s!
+#include <linux/config.h>
+
+INITSEG  = DEF_INITSEG			! we move boot here - out of the way	
+SYSSEG   = DEF_SYSSEG			! system loaded at 0x10000 (65536).		
+SETUPSEG = DEF_SETUPSEG			! this is the current segment			
+
+.globl begtext, begdata, begbss, endtext, enddata, endbss
+.text
+begtext:
+.data
+begdata:
+.bss
+begbss:
+.text
+
+entry start
+start:
+
+! ok, the read went well so we get current cursor position and save it for
+! posterity.
+
+
+	mov	ax, #INITSEG							! this is done in bootsect already, but...
+	mov	ds, ax
+
+	! Get memory size (extended mem, kB)
+	mov	ah, #0x88
+	int	0x15
+	mov	[2], ax									
+
+	! check for EGA/VGA and some config parameters
+
+	mov	ah, #0x12
+	mov	bl, #0x10
+	int	0x10
+	mov	[8], ax								
+	mov	[10], bx						
+	mov	[12], cx						
+	mov	ax, #0x5019						
+	cmp	bl, #0x10							 
+	je	novga
+	call	chsvga							
+novga:
+	mov	[14], ax							
+	mov	ah, #0x03							
+	xor	bh, bh
+	int	0x10								
+	mov	[0], dx								
+
+	! Get video-card data:
+
+	mov	ah, #0x0f
+	int	0x10
+	mov	[4], bx								
+	mov	[6], ax								
+
+	! Get hd0 data
+	mov	ax, #0x0000
+	mov	ds, ax
+	lds	si, [4 * 0x41]						
+	mov	ax, #INITSEG
+	mov	es, ax
+	mov	di, #0x0080							
+	mov	cx, #0x10							
+	rep
+	movsb
+
+	! Get hd1 data
+
+	mov	ax, #0x0000
+	mov	ds, ax
+	lds	si, [4 * 0x46]						
+	mov	ax, #INITSEG
+	mov	es, ax
+	mov	di, #0x0090								
+	mov	cx, #0x10
+	rep
+	movsb
+	! Check that there IS a hd1 :-)
+	mov	ax, #0x01500
+	mov	dl, #0x81
+	int	0x13
+	jc	no_disk1
+	cmp	ah, #3									
+	je	is_disk1
+no_disk1:
+	mov	ax, #INITSEG							
+	mov	es, ax
+	mov	di, #0x0090
+	mov	cx, #0x10
+	mov	ax, #0x00
+	rep
+	stosb
+is_disk1:
+
+! now we want to move to protected mode ...
+
+	cli											! no interrupts allowed !	
+	! first we move the system to it's rightful place
+	mov	ax, #0x0000
+	cld											! 'direction'=0, movs moves forward
+do_move:
+	mov	es, ax									! destination segment	
+	add	ax, #0x1000
+	cmp	ax, #0x9000								
+	jz	end_move								
+	mov	ds, ax									! source segment	
+	sub	di, di
+	sub	si, si
+	mov cx, #0x8000								
+	rep
+	movsw
+	jmp	do_move
+
+	! then we load the segment descriptors
+end_move:
+	mov	ax, #SETUPSEG							! right, forgot this at first. didn't work :-)
+	mov	ds, ax									
+	lidt	idt_48								! load idt with 0,0	
+	lgdt	gdt_48								! load gdt with whatever appropriate
+
+	! that was painless, now we enable A20
+	call	empty_8042							
+	mov	al, #0xD1								
+	out	#0x64, al
+	call	empty_8042							
+	mov	al, #0xDF								
+	out	#0x60, al								
+	call	empty_8042							
+
+! well, that went ok, I hope. Now we have to reprogram the interrupts :-(
+! we put them right after the intel-reserved hardware interrupts, at
+! int 0x20-0x2F. There they won't mess up anything. Sadly IBM really
+! messed this up with the original PC, and they haven't been able to
+! rectify it afterwards. Thus the bios puts interrupts at 0x08-0x0f,
+! which is used for the internal hardware interrupts as well. We just
+! have to reprogram the 8259's, and it isn't fun.
+
+	mov	al, #0x11								! initialization sequence
+	out	#0x20, al								! send it to 8259A-1
+	.word	0x00eb, 0x00eb						! jmp $+2, jmp $+2 
+	out	#0xA0, al								! and to 8259A-2   
+	.word	0x00eb, 0x00eb
+	mov	al, #0x20								! start of hardware int's (0x20)
+	out	#0x21, al								
+	.word	0x00eb, 0x00eb
+	mov	al, #0x28								! start of hardware int's 2 (0x28)
+	out	#0xA1, al						
+	.word	0x00eb, 0x00eb
+
+	mov	al, #0x04								! 8259-1 is master
+	out	#0x21, al							
+	.word	0x00eb, 0x00eb
+	mov	al, #0x02								! 8259-2 is slave
+	out	#0xA1, al								
+
+	.word	0x00eb, 0x00eb
+	mov	al, #0x01								! 8086 mode for both
+	out	#0x21, al							   
+	.word	0x00eb, 0x00eb
+	out	#0xA1, al							   
+	.word	0x00eb, 0x00eb
+	mov	al, #0xFF								! mask off all interrupts for now
+	out	#0x21, al							
+	.word	0x00eb, 0x00eb
+	out	#0xA1, al								
+
+	! well, that certainly wasn't fun :-(. Hopefully it works, and we don't
+	! need no steenking BIOS anyway (except for the initial loading :-).
+	! The BIOS-routine wants lots of unnecessary data, and it's less
+	! "interesting" anyway. This is how REAL programmers do it.
+	!
+	! Well, now's the time to actually move into protected mode. To make
+	! things as simple as possible, we do no register set-up or anything,
+	! we let the gnu-compiled 32-bit programs do that. We just jump to
+	! absolute address 0x00000, in 32-bit protected mode.
+	!
+
+	mov	ax, #0x0001								! protected mode (PE) bit
+	lmsw	ax									! This is it!			
+	jmpi	0, 8								! jmp offset 0 of segment 8 (cs)	
+
+! This routine checks that the keyboard command queue is empty
+! No timeout is used - if this hangs there is something wrong with
+! the machine, and we probably couldn't proceed anyway.
+empty_8042:
+	.word	0x00eb, 0x00eb
+	in	al, #0x64								! 8042 status port	
+	test	al, #2								! is input buffer full?	
+	jnz	empty_8042								! yes - loop
+	ret
+
+! Routine trying to recognize type of SVGA-board present (if any)
+! and if it recognize one gives the choices of resolution it offers.
+! If one is found the resolution chosen is given by al,ah (rows,cols).
+
+chsvga:
+	cld
+	push	ds
+	push	cs
+	pop	ds
+	mov 	ax, #0xc000
+	mov	es, ax
+	lea	si, msg1
+	call	prtstr
+nokey:
+	in	al, #0x60
+	cmp	al, #0x82
+	jb	nokey
+	cmp	al, #0xe0
+	ja	nokey
+	cmp	al, #0x9c
+	je	svga
+	mov	ax, #0x5019
+	pop	ds
+	ret
+svga:
+	lea si, idati								! Check ATI 'clues'
+	mov	di, #0x31
+	mov cx, #0x09
+	repe
+	cmpsb
+	jne	noati
+	lea	si, dscati
+	lea	di, moati
+	lea	cx, selmod
+	jmp	cx
+noati:
+	mov	ax, #0x200f								! Check Ahead 'clues'
+	mov	dx, #0x3ce
+	out	dx, ax
+	inc	dx
+	in	al, dx
+	cmp	al, #0x20
+	je	isahed
+	cmp	al, #0x21
+	jne	noahed
+isahed:
+	lea	si, dscahead
+	lea	di, moahead
+	lea	cx, selmod
+	jmp	cx
+noahed:
+	mov	dx, #0x3c3								! Check Chips & Tech. 'clues'
+	in	al, dx
+	or	al, #0x10
+	out	dx, al
+	mov	dx, #0x104
+	in	al, dx
+	mov	bl, al
+	mov	dx, #0x3c3
+	in	al, dx
+	and	al, #0xef
+	out	dx, al
+	cmp	bl, [idcandt]
+	jne	nocant
+	lea	si, dsccandt
+	lea	di, mocandt
+	lea	cx, selmod
+	jmp	cx
+nocant:
+	mov	dx, #0x3d4								! Check Cirrus 'clues'
+	mov	al, #0x0c
+	out	dx, al
+	inc	dx
+	in	al, dx
+	mov	bl, al
+	xor	al, al
+	out	dx, al
+	dec	dx
+	mov	al, #0x1f
+	out	dx, al
+	inc	dx
+	in	al, dx
+	mov	bh, al
+	xor	ah, ah
+	shl	al, #4
+	mov	cx, ax
+	mov	al, bh
+	shr	al, #4
+	add	cx, ax
+	shl	cx, #8
+	add	cx, #6
+	mov	ax, cx
+	mov	dx, #0x3c4
+	out	dx, ax
+	inc	dx
+	in	al, dx
+	and	al, al
+	jnz	nocirr
+	mov	al, bh
+	out	dx, al
+	in	al, dx
+	cmp	al, #0x01
+	jne	nocirr
+	call	rst3d4
+	lea	si, dsccirrus
+	lea	di, mocirrus
+	lea	cx, selmod
+	jmp	cx
+rst3d4:
+	mov	dx, #0x3d4
+	mov	al, bl
+	xor	ah, ah
+	shl	ax, #8
+	add	ax, #0x0c
+	out	dx, ax
+	ret
+nocirr:
+	call	rst3d4								! Check Everex 'clues'
+	mov	ax, #0x7000
+	xor	bx, bx
+	int	0x10
+	cmp	al, #0x70
+	jne	noevrx
+	shr	dx, #4
+	cmp	dx, #0x678
+	je	istrid
+	cmp	dx, #0x236
+	je	istrid
+	lea	si, dsceverex
+	lea	di, moeverex
+	lea	cx, selmod
+	jmp	cx
+istrid:
+	lea	cx, ev2tri
+	jmp	cx
+noevrx:
+	lea	si, idgenoa								! Check Genoa 'clues'
+	xor ax, ax
+	seg es
+	mov	al, [0x37]
+	mov	di, ax
+	mov	cx, #0x04
+	dec	si
+	dec	di
+l1:
+	inc	si
+	inc	di
+	mov	al, (si)
+	seg es
+	and	al, (di)
+	cmp	al, (si)
+	loope 	l1
+	cmp	cx, #0x00
+	jne	nogen
+	lea	si, dscgenoa
+	lea	di, mogenoa
+	lea	cx, selmod
+	jmp	cx
+nogen:
+	lea	si, idparadise							! Check Paradise 'clues'
+	mov	di, #0x7d
+	mov	cx, #0x04
+	repe
+	cmpsb
+	jne	nopara
+	lea	si, dscparadise
+	lea	di, moparadise
+	lea	cx, selmod
+	jmp	cx
+nopara:
+	mov	dx, #0x3c4								! Check Trident 'clues'
+	mov	al, #0x0e
+	out	dx, al
+	inc	dx
+	in	al, dx
+	xchg ah, al
+	mov	al, #0x00
+	out	dx, al
+	in	al, dx
+	xchg al,ah
+	mov	bl, al									! Strange thing ... in the book this wasn't
+	and	bl, #0x02								! necessary but it worked on my card which
+	jz	setb2									! is a trident. Without it the screen goes
+	and	al, #0xfd								! blurred ...
+	jmp	clrb2									!
+setb2:
+	or	al, #0x02								!
+clrb2:
+	out	dx, al
+	and	ah, #0x0f
+	cmp	ah, #0x02
+	jne	notrid
+ev2tri:
+	lea	si, dsctrident
+	lea	di, motrident
+	lea	cx, selmod
+	jmp	cx
+notrid:
+	mov	dx, #0x3cd								! Check Tseng 'clues'
+	in	al, dx									! Could things be this simple ! :-)
+	mov	bl, al
+	mov	al, #0x55
+	out	dx, al
+	in	al, dx
+	mov	ah, al
+	mov	al, bl
+	out	dx, al
+	cmp	ah, #0x55
+ 	jne	notsen
+	lea	si, dsctseng
+	lea	di, motseng
+	lea	cx, selmod
+	jmp	cx
+notsen:
+	mov	dx, #0x3cc								! Check Video7 'clues'
+	in	al, dx
+	mov	dx, #0x3b4
+	and	al, #0x01
+	jz	even7
+	mov	dx, #0x3d4
+even7:
+	mov	al, #0x0c
+	out	dx, al
+	inc	dx
+	in	al, dx
+	mov	bl, al
+	mov	al, #0x55
+	out	dx, al
+	in	al, dx
+	dec	dx
+	mov	al, #0x1f
+	out	dx, al
+	inc	dx
+	in	al, dx
+	mov	bh, al
+	dec	dx
+	mov	al, #0x0c
+	out	dx, al
+	inc	dx
+	mov	al, bl
+	out	dx, al
+	mov	al, #0x55
+	xor	al, #0xea
+	cmp	al, bh
+	jne	novid7
+	lea	si, dscvideo7
+	lea	di, movideo7
+selmod:
+	push	si
+	lea	si, msg2
+	call	prtstr
+	xor	cx, cx
+	mov	cl, (di)
+	pop	si
+	push	si
+	push	cx
+tbl:
+	pop	bx
+	push bx
+	mov	al, bl
+	sub	al, cl
+	call dprnt
+	call spcing
+	lodsw
+	xchg al, ah
+	call dprnt
+	xchg ah, al
+	push ax
+	mov	al, #0x78
+	call prnt1
+	pop	ax
+	call	dprnt
+	call	docr
+	loop	tbl
+	pop	cx
+	call	docr
+	lea	si, msg3
+	call	prtstr
+	pop	si
+	add	cl, #0x80
+nonum:
+	in	al, #0x60							! Quick and dirty...
+	cmp	al, #0x82
+	jb	nonum
+	cmp	al, #0x8b
+	je	zero
+	cmp	al, cl
+	ja	nonum
+	jmp	nozero
+zero:
+	sub	al, #0x0a
+nozero:
+	sub	al, #0x80
+	dec	al
+	xor	ah, ah
+	add	di, ax
+	inc	di
+	push	ax
+	mov	al, (di)
+	int 	0x10
+	pop	ax
+	shl	ax, #1
+	add	si, ax
+	lodsw
+	pop	ds
+	ret
+novid7:
+	pop	ds										! Here could be code to support standard 80x50,80x30
+	mov	ax, #0x5019
+	ret
+
+! Routine that 'tabs' to next col.
+
+spcing:
+	mov	al, #0x2e
+	call	prnt1
+	mov	al, #0x20
+	call	prnt1
+	mov	al, #0x20
+	call	prnt1
+	mov	al, #0x20
+	call	prnt1
+	mov	al, #0x20
+	call	prnt1
+	ret
+
+! Routine to print asciiz-string at DS:SI
+
+prtstr:
+	lodsb
+	and	al, al
+	jz	fin
+	call	prnt1
+	jmp	prtstr
+fin:
+	ret
+
+! Routine to print a decimal value on screen, the value to be
+! printed is put in al (i.e 0-255).
+
+dprnt:
+	push	ax
+	push	cx
+	mov	ah, #0x00
+	mov	cl, #0x0a
+	idiv	cl
+	cmp	al, #0x09
+	jbe	lt100
+	call	dprnt
+	jmp	skip10
+lt100:
+	add	al, #0x30
+	call	prnt1
+skip10:
+	mov	al, ah
+	add	al, #0x30
+	call	prnt1
+	pop	cx
+	pop	ax
+	ret
+
+! Part of above routine, this one just prints ascii al
+
+prnt1:
+	push	ax
+	push	cx
+	mov	bh, #0x00
+	mov	cx, #0x01
+	mov	ah, #0x0e
+	int	0x10
+	pop	cx
+	pop	ax
+	ret
+
+! Prints <CR> + <LF>
+
+docr:
+	push	ax
+	push	cx
+	mov	bh, #0x00
+	mov	ah, #0x0e
+	mov	al, #0x0a
+	mov	cx, #0x01
+	int	0x10
+	mov	al, #0x0d
+	int	0x10
+	pop	cx
+	pop	ax
+	ret
+
+gdt:
+	.word	0, 0, 0, 0						! dummy	!
+
+	.word	0x07FF							! 8Mb - limit=2047 (2048*4096=8Mb)	
+	.word	0x0000							! base address=0
+	.word	0x9A00							! code read/exec			
+	.word	0x00C0							! granularity=4096, 386		
+
+	.word	0x07FF							! 8Mb - limit=2047 (2048*4096=8Mb)	! (2048*4096B=8MB)
+	.word	0x0000							! base address=0
+	.word	0x9200							! data read/write			
+	.word	0x00C0							! granularity=4096, 386		
+
+idt_48:
+	.word	0								! idt limit=0
+	.word	0, 0							! idt base=0L
+
+gdt_48:
+	.word	0x800							! gdt limit=2048, 256 GDT entries
+	.word	512 + gdt, 0x9					! gdt base = 0X9xxxx
+
+msg1:		.ascii	"Press <RETURN> to see SVGA-modes available or any other key to continue."
+		db	0x0d, 0x0a, 0x0a, 0x00
+msg2:		.ascii	"Mode:  COLSxROWS:"
+		db	0x0d, 0x0a, 0x0a, 0x00
+msg3:		.ascii	"Choose mode by pressing the corresponding number."
+		db	0x0d, 0x0a, 0x00
+
+idati:		.ascii	"761295520"
+idcandt:	.byte	0xa5
+idgenoa:	.byte	0x77, 0x00, 0x66, 0x99
+idparadise:	.ascii	"VGA="
+
+! Manufacturer:	  Numofmodes:	Mode:
+
+moati:		.byte	0x02,	0x23, 0x33
+moahead:	.byte	0x05,	0x22, 0x23, 0x24, 0x2f, 0x34
+mocandt:	.byte	0x02,	0x60, 0x61
+mocirrus:	.byte	0x04,	0x1f, 0x20, 0x22, 0x31
+moeverex:	.byte	0x0a,	0x03, 0x04, 0x07, 0x08, 0x0a, 0x0b, 0x16, 0x18, 0x21, 0x40
+mogenoa:	.byte	0x0a,	0x58, 0x5a, 0x60, 0x61, 0x62, 0x63, 0x64, 0x72, 0x74, 0x78
+moparadise:	.byte	0x02,	0x55, 0x54
+motrident:	.byte	0x07,	0x50, 0x51, 0x52, 0x57, 0x58, 0x59, 0x5a
+motseng:	.byte	0x05,	0x26, 0x2a, 0x23, 0x24, 0x22
+movideo7:	.byte	0x06,	0x40, 0x43, 0x44, 0x41, 0x42, 0x45
+
+!			msb = Cols lsb = Rows:
+
+dscati:		.word	0x8419, 0x842c
+dscahead:	.word	0x842c, 0x8419, 0x841c, 0xa032, 0x5042
+dsccandt:	.word	0x8419, 0x8432
+dsccirrus:	.word	0x8419, 0x842c, 0x841e, 0x6425
+dsceverex:	.word	0x5022, 0x503c, 0x642b, 0x644b, 0x8419, 0x842c, 0x501e, 0x641b, 0xa040, 0x841e
+dscgenoa:	.word	0x5020, 0x642a, 0x8419, 0x841d, 0x8420, 0x842c, 0x843c, 0x503c, 0x5042, 0x644b
+dscparadise:	.word	0x8419, 0x842b
+dsctrident:	.word 	0x501e, 0x502b, 0x503c, 0x8419, 0x841e, 0x842b, 0x843c
+dsctseng:	.word	0x503c, 0x6428, 0x8419, 0x841c, 0x842c
+dscvideo7:	.word	0x502b, 0x503c, 0x643c, 0x8419, 0x842c, 0x841c
+
+.text
+endtext:
+.data
+enddata:
+.bss
+endbss:
diff --git a/fs/Makefile b/fs/Makefile
index fd00c1a..c3a5715 100755
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -1,129 +1,123 @@
-AR	=gar
-AS	=gas
-CC	=gcc
-LD	=gld
-CFLAGS	=-Wall -O -fstrength-reduce -fcombine-regs -fomit-frame-pointer \
-	-fno-defer-pop -mstring-insns -nostdinc -I../include
-CPP	=gcc -E -nostdinc -I../include
-
-.c.s:
-	$(CC) $(CFLAGS) \
-	-S -o $*.s $<
-.c.o:
-	$(CC) $(CFLAGS) \
-	-c -o $*.o $<
-.s.o:
-	$(AS) -o $*.o $<
-
-OBJS=	open.o read_write.o inode.o file_table.o buffer.o super.o \
-	block_dev.o char_dev.o file_dev.o stat.o exec.o pipe.o namei.o \
-	bitmap.o fcntl.o ioctl.o truncate.o select.o
-
-fs.o: $(OBJS)
-	$(LD) -r -o fs.o $(OBJS)
-
-clean:
-	rm -f core *.o *.a tmp_make
-	for i in *.c;do rm -f `basename $$i .c`.s;done
-
-dep:
-	sed '/\#\#\# Dependencies/q' < Makefile > tmp_make
-	(for i in *.c;do $(CPP) -M $$i;done) >> tmp_make
-	cp tmp_make Makefile
-
-### Dependencies:
-bitmap.o : bitmap.c ../include/string.h ../include/viz/sched.h \
-  ../include/viz/head.h ../include/viz/fs.h ../include/sys/types.h \
-  ../include/viz/mm.h ../include/viz/kernel.h ../include/signal.h \
-  ../include/sys/param.h ../include/sys/time.h ../include/time.h \
-  ../include/sys/resource.h 
-block_dev.o : block_dev.c ../include/errno.h ../include/viz/sched.h \
-  ../include/viz/head.h ../include/viz/fs.h ../include/sys/types.h \
-  ../include/viz/mm.h ../include/viz/kernel.h ../include/signal.h \
-  ../include/sys/param.h ../include/sys/time.h ../include/time.h \
-  ../include/sys/resource.h ../include/asm/segment.h ../include/asm/system.h 
-buffer.o : buffer.c ../include/stdarg.h ../include/viz/config.h \
-  ../include/viz/sched.h ../include/viz/head.h ../include/viz/fs.h \
-  ../include/sys/types.h ../include/viz/mm.h ../include/viz/kernel.h \
-  ../include/signal.h ../include/sys/param.h ../include/sys/time.h \
-  ../include/time.h ../include/sys/resource.h ../include/asm/system.h \
-  ../include/asm/io.h 
-char_dev.o : char_dev.c ../include/errno.h ../include/sys/types.h \
-  ../include/viz/sched.h ../include/viz/head.h ../include/viz/fs.h \
-  ../include/viz/mm.h ../include/viz/kernel.h ../include/signal.h \
-  ../include/sys/param.h ../include/sys/time.h ../include/time.h \
-  ../include/sys/resource.h ../include/asm/segment.h ../include/asm/io.h 
-exec.o : exec.c ../include/signal.h ../include/sys/types.h \
-  ../include/errno.h ../include/string.h ../include/sys/stat.h \
-  ../include/a.out.h ../include/viz/fs.h ../include/viz/sched.h \
-  ../include/viz/head.h ../include/viz/mm.h ../include/viz/kernel.h \
-  ../include/sys/param.h ../include/sys/time.h ../include/time.h \
-  ../include/sys/resource.h ../include/asm/segment.h 
-fcntl.o : fcntl.c ../include/string.h ../include/errno.h \
-  ../include/viz/sched.h ../include/viz/head.h ../include/viz/fs.h \
-  ../include/sys/types.h ../include/viz/mm.h ../include/viz/kernel.h \
-  ../include/signal.h ../include/sys/param.h ../include/sys/time.h \
-  ../include/time.h ../include/sys/resource.h ../include/asm/segment.h \
-  ../include/fcntl.h ../include/sys/stat.h 
-file_dev.o : file_dev.c ../include/errno.h ../include/fcntl.h \
-  ../include/sys/types.h ../include/viz/sched.h ../include/viz/head.h \
-  ../include/viz/fs.h ../include/viz/mm.h ../include/viz/kernel.h \
-  ../include/signal.h ../include/sys/param.h ../include/sys/time.h \
-  ../include/time.h ../include/sys/resource.h ../include/asm/segment.h 
-file_table.o : file_table.c ../include/viz/fs.h ../include/sys/types.h 
-inode.o : inode.c ../include/string.h ../include/sys/stat.h \
-  ../include/sys/types.h ../include/viz/sched.h ../include/viz/head.h \
-  ../include/viz/fs.h ../include/viz/mm.h ../include/viz/kernel.h \
-  ../include/signal.h ../include/sys/param.h ../include/sys/time.h \
-  ../include/time.h ../include/sys/resource.h ../include/asm/system.h 
-ioctl.o : ioctl.c ../include/string.h ../include/errno.h \
-  ../include/sys/stat.h ../include/sys/types.h ../include/viz/sched.h \
-  ../include/viz/head.h ../include/viz/fs.h ../include/viz/mm.h \
-  ../include/viz/kernel.h ../include/signal.h ../include/sys/param.h \
-  ../include/sys/time.h ../include/time.h ../include/sys/resource.h 
-namei.o : namei.c ../include/viz/sched.h ../include/viz/head.h \
-  ../include/viz/fs.h ../include/sys/types.h ../include/viz/mm.h \
-  ../include/viz/kernel.h ../include/signal.h ../include/sys/param.h \
-  ../include/sys/time.h ../include/time.h ../include/sys/resource.h \
-  ../include/asm/segment.h ../include/string.h ../include/fcntl.h \
-  ../include/errno.h ../include/const.h ../include/sys/stat.h 
-open.o : open.c ../include/string.h ../include/errno.h ../include/fcntl.h \
-  ../include/sys/types.h ../include/utime.h ../include/sys/stat.h \
-  ../include/viz/sched.h ../include/viz/head.h ../include/viz/fs.h \
-  ../include/viz/mm.h ../include/viz/kernel.h ../include/signal.h \
-  ../include/sys/param.h ../include/sys/time.h ../include/time.h \
-  ../include/sys/resource.h ../include/viz/tty.h ../include/termios.h \
-  ../include/asm/segment.h 
-pipe.o : pipe.c ../include/signal.h ../include/sys/types.h \
-  ../include/errno.h ../include/termios.h ../include/viz/sched.h \
-  ../include/viz/head.h ../include/viz/fs.h ../include/viz/mm.h \
-  ../include/viz/kernel.h ../include/sys/param.h ../include/sys/time.h \
-  ../include/time.h ../include/sys/resource.h ../include/asm/segment.h 
-read_write.o : read_write.c ../include/sys/stat.h ../include/sys/types.h \
-  ../include/errno.h ../include/viz/kernel.h ../include/viz/sched.h \
-  ../include/viz/head.h ../include/viz/fs.h ../include/viz/mm.h \
-  ../include/signal.h ../include/sys/param.h ../include/sys/time.h \
-  ../include/time.h ../include/sys/resource.h ../include/asm/segment.h 
-select.o : select.c ../include/viz/fs.h ../include/sys/types.h \
-  ../include/viz/kernel.h ../include/viz/tty.h ../include/termios.h \
-  ../include/viz/sched.h ../include/viz/head.h ../include/viz/mm.h \
-  ../include/signal.h ../include/sys/param.h ../include/sys/time.h \
-  ../include/time.h ../include/sys/resource.h ../include/asm/segment.h \
-  ../include/asm/system.h ../include/sys/stat.h ../include/string.h \
-  ../include/const.h ../include/errno.h 
-stat.o : stat.c ../include/errno.h ../include/sys/stat.h \
-  ../include/sys/types.h ../include/viz/fs.h ../include/viz/sched.h \
-  ../include/viz/head.h ../include/viz/mm.h ../include/viz/kernel.h \
-  ../include/signal.h ../include/sys/param.h ../include/sys/time.h \
-  ../include/time.h ../include/sys/resource.h ../include/asm/segment.h 
-super.o : super.c ../include/viz/config.h ../include/viz/sched.h \
-  ../include/viz/head.h ../include/viz/fs.h ../include/sys/types.h \
-  ../include/viz/mm.h ../include/viz/kernel.h ../include/signal.h \
-  ../include/sys/param.h ../include/sys/time.h ../include/time.h \
-  ../include/sys/resource.h ../include/asm/system.h ../include/errno.h \
-  ../include/sys/stat.h 
-truncate.o : truncate.c ../include/viz/sched.h ../include/viz/head.h \
-  ../include/viz/fs.h ../include/sys/types.h ../include/viz/mm.h \
-  ../include/viz/kernel.h ../include/signal.h ../include/sys/param.h \
-  ../include/sys/time.h ../include/time.h ../include/sys/resource.h \
-  ../include/sys/stat.h 
+include ../Makefile.header
+
+LDFLAGS += -r
+CFLAGS	+= -fno-defer-pop -nostdinc -I../include
+CPP	+= -I../include
+
+.c.s:
+	@$(CC) $(CFLAGS) \
+	-S -o $*.s $<
+.c.o:
+	@$(CC) $(CFLAGS) \
+	-c -o $*.o $<
+.s.o:
+	$(AS) -o $*.o $<
+
+OBJS=	open.o read_write.o inode.o file_table.o buffer.o super.o \
+	block_dev.o char_dev.o file_dev.o stat.o exec.o pipe.o namei.o \
+	bitmap.o fcntl.o ioctl.o truncate.o select.o
+
+fs.o: $(OBJS)
+	@$(LD) $(LDFLAGS) -o fs.o $(OBJS)
+
+clean:
+	@rm -f core *.o *.a tmp_make
+	@for i in *.c;do rm -f `basename $$i .c`.s;done
+
+dep:
+	@sed '/\#\#\# Dependencies/q' < Makefile > tmp_make
+	@(for i in *.c;do $(CPP) -M $$i;done) >> tmp_make
+	@cp tmp_make Makefile
+
+### Dependencies:
+bitmap.o: bitmap.c ../include/string.h ../include/viz/sched.h \
+ ../include/viz/head.h ../include/viz/fs.h ../include/sys/types.h \
+ ../include/viz/mm.h ../include/viz/kernel.h ../include/signal.h \
+ ../include/sys/param.h ../include/sys/time.h ../include/time.h \
+ ../include/sys/resource.h
+block_dev.o: block_dev.c ../include/errno.h ../include/viz/sched.h \
+ ../include/viz/head.h ../include/viz/fs.h ../include/sys/types.h \
+ ../include/viz/mm.h ../include/viz/kernel.h ../include/signal.h \
+ ../include/sys/param.h ../include/sys/time.h ../include/time.h \
+ ../include/sys/resource.h ../include/asm/segment.h
+buffer.o: buffer.c ../include/stdarg.h ../include/viz/sched.h \
+ ../include/viz/head.h ../include/viz/fs.h ../include/sys/types.h \
+ ../include/viz/mm.h ../include/viz/kernel.h ../include/signal.h \
+ ../include/sys/param.h ../include/sys/time.h ../include/time.h \
+ ../include/sys/resource.h ../include/asm/system.h
+char_dev.o: char_dev.c ../include/errno.h ../include/sys/types.h \
+ ../include/viz/sched.h ../include/viz/head.h ../include/viz/fs.h \
+ ../include/viz/mm.h ../include/viz/kernel.h ../include/signal.h \
+ ../include/sys/param.h ../include/sys/time.h ../include/time.h \
+ ../include/sys/resource.h ../include/asm/segment.h ../include/asm/io.h
+exec.o: exec.c ../include/errno.h ../include/string.h \
+ ../include/sys/stat.h ../include/sys/types.h ../include/a.out.h \
+ ../include/viz/fs.h ../include/viz/sched.h ../include/viz/head.h \
+ ../include/viz/mm.h ../include/viz/kernel.h ../include/signal.h \
+ ../include/sys/param.h ../include/sys/time.h ../include/time.h \
+ ../include/sys/resource.h ../include/asm/segment.h
+fcntl.o: fcntl.c ../include/errno.h ../include/viz/sched.h \
+ ../include/viz/head.h ../include/viz/fs.h ../include/sys/types.h \
+ ../include/viz/mm.h ../include/viz/kernel.h ../include/signal.h \
+ ../include/sys/param.h ../include/sys/time.h ../include/time.h \
+ ../include/sys/resource.h ../include/fcntl.h
+file_dev.o: file_dev.c ../include/errno.h ../include/fcntl.h \
+ ../include/sys/types.h ../include/viz/sched.h ../include/viz/head.h \
+ ../include/viz/fs.h ../include/viz/mm.h ../include/viz/kernel.h \
+ ../include/signal.h ../include/sys/param.h ../include/sys/time.h \
+ ../include/time.h ../include/sys/resource.h ../include/asm/segment.h
+file_table.o: file_table.c ../include/viz/fs.h ../include/sys/types.h
+inode.o: inode.c ../include/string.h ../include/sys/stat.h \
+ ../include/sys/types.h ../include/viz/sched.h ../include/viz/head.h \
+ ../include/viz/fs.h ../include/viz/mm.h ../include/viz/kernel.h \
+ ../include/signal.h ../include/sys/param.h ../include/sys/time.h \
+ ../include/time.h ../include/sys/resource.h ../include/asm/system.h
+ioctl.o: ioctl.c ../include/errno.h ../include/sys/stat.h \
+ ../include/sys/types.h ../include/viz/sched.h ../include/viz/head.h \
+ ../include/viz/fs.h ../include/viz/mm.h ../include/viz/kernel.h \
+ ../include/signal.h ../include/sys/param.h ../include/sys/time.h \
+ ../include/time.h ../include/sys/resource.h
+namei.o: namei.c ../include/viz/sched.h ../include/viz/head.h \
+ ../include/viz/fs.h ../include/sys/types.h ../include/viz/mm.h \
+ ../include/viz/kernel.h ../include/signal.h ../include/sys/param.h \
+ ../include/sys/time.h ../include/time.h ../include/sys/resource.h \
+ ../include/asm/segment.h ../include/string.h ../include/fcntl.h \
+ ../include/errno.h ../include/const.h ../include/sys/stat.h
+open.o: open.c ../include/errno.h ../include/fcntl.h \
+ ../include/sys/types.h ../include/utime.h ../include/sys/stat.h \
+ ../include/viz/sched.h ../include/viz/head.h ../include/viz/fs.h \
+ ../include/viz/mm.h ../include/viz/kernel.h ../include/signal.h \
+ ../include/sys/param.h ../include/sys/time.h ../include/time.h \
+ ../include/sys/resource.h ../include/viz/tty.h ../include/termios.h \
+ ../include/asm/segment.h
+pipe.o: pipe.c ../include/errno.h ../include/termios.h \
+ ../include/sys/types.h ../include/viz/sched.h ../include/viz/head.h \
+ ../include/viz/fs.h ../include/viz/mm.h ../include/viz/kernel.h \
+ ../include/signal.h ../include/sys/param.h ../include/sys/time.h \
+ ../include/time.h ../include/sys/resource.h ../include/asm/segment.h
+read_write.o: read_write.c ../include/sys/stat.h ../include/sys/types.h \
+ ../include/errno.h ../include/viz/kernel.h ../include/viz/sched.h \
+ ../include/viz/head.h ../include/viz/fs.h ../include/viz/mm.h \
+ ../include/signal.h ../include/sys/param.h ../include/sys/time.h \
+ ../include/time.h ../include/sys/resource.h ../include/asm/segment.h
+select.o: select.c ../include/viz/kernel.h ../include/viz/tty.h \
+ ../include/termios.h ../include/sys/types.h ../include/viz/sched.h \
+ ../include/viz/head.h ../include/viz/fs.h ../include/viz/mm.h \
+ ../include/signal.h ../include/sys/param.h ../include/sys/time.h \
+ ../include/time.h ../include/sys/resource.h ../include/asm/segment.h \
+ ../include/asm/system.h ../include/sys/stat.h ../include/errno.h
+stat.o: stat.c ../include/errno.h ../include/sys/stat.h \
+ ../include/sys/types.h ../include/viz/fs.h ../include/viz/sched.h \
+ ../include/viz/head.h ../include/viz/mm.h ../include/viz/kernel.h \
+ ../include/signal.h ../include/sys/param.h ../include/sys/time.h \
+ ../include/time.h ../include/sys/resource.h ../include/asm/segment.h
+super.o: super.c ../include/viz/sched.h ../include/viz/head.h \
+ ../include/viz/fs.h ../include/sys/types.h ../include/viz/mm.h \
+ ../include/viz/kernel.h ../include/signal.h ../include/sys/param.h \
+ ../include/sys/time.h ../include/time.h ../include/sys/resource.h \
+ ../include/asm/system.h ../include/errno.h ../include/sys/stat.h
+truncate.o: truncate.c ../include/viz/sched.h ../include/viz/head.h \
+ ../include/viz/fs.h ../include/sys/types.h ../include/viz/mm.h \
+ ../include/viz/kernel.h ../include/signal.h ../include/sys/param.h \
+ ../include/sys/time.h ../include/time.h ../include/sys/resource.h \
+ ../include/sys/stat.h
diff --git a/fs/bitmap.c b/fs/bitmap.c
index 2d623a4..3ffe63e 100755
--- a/fs/bitmap.c
+++ b/fs/bitmap.c
@@ -14,7 +14,7 @@
 __asm__("cld\n\t" \
 	"rep\n\t" \
 	"stosl" \
-	::"a" (0),"c" (BLOCK_SIZE/4),"D" ((long) (addr)):"cx","di")
+	::"a" (0),"c" (BLOCK_SIZE/4),"D" ((long) (addr)):)
 
 #define set_bit(nr,addr) ({\
 register int res __asm__("ax"); \
@@ -41,7 +41,7 @@ __asm__("cld\n" \
 	"cmpl $8192,%%ecx\n\t" \
 	"jl 1b\n" \
 	"3:" \
-	:"=c" (__res):"c" (0),"S" (addr):"ax","dx","si"); \
+	:"=c" (__res):"c" (0),"S" (addr):"ax", "dx"); \
 __res;})
 
 int free_block(int dev, int block)
diff --git a/fs/buffer.c b/fs/buffer.c
index bd5f3a1..75e830d 100755
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@ -285,7 +285,7 @@ __asm__("cld\n\t" \
 	"rep\n\t" \
 	"movsl\n\t" \
 	::"c" (BLOCK_SIZE/4),"S" (from),"D" (to) \
-	:"cx","di","si")
+	:)
 
 /*
  * bread_page reads four buffers into memory at the desired address. It's
diff --git a/fs/exec.c b/fs/exec.c
index c1f5b45..a0d7547 100755
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -159,8 +159,8 @@ static unsigned long copy_strings(int argc,char ** argv,unsigned long *page,
 				if (from_kmem==2)
 					set_fs(old_fs);
 				if (!(pag = (char *) page[p/PAGE_SIZE]) &&
-				    !(pag = (char *) page[p/PAGE_SIZE] =
-				      (unsigned long *) get_free_page())) 
+				    !(pag = (char *) (page[p/PAGE_SIZE] =
+				      (unsigned long *) get_free_page()))) 
 					return 0;
 				if (from_kmem==2)
 					set_fs(new_fs);
diff --git a/fs/namei.c b/fs/namei.c
index 0c695b1..e708eac 100755
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -79,7 +79,7 @@ static int match(int len,const char * name,struct dir_entry * de)
 		"setz %%al"
 		:"=a" (same)
 		:"0" (0),"S" ((long) name),"D" ((long) de->name),"c" (len)
-		:"cx","di","si");
+		:);
 	return same;
 }
 
diff --git a/include/asm/memory.h b/include/asm/memory.h
index dba1062..7410f49 100755
--- a/include/asm/memory.h
+++ b/include/asm/memory.h
@@ -9,6 +9,6 @@
 void * _res = dest; \
 __asm__ ("cld;rep;movsb" \
 	::"D" ((long)(_res)),"S" ((long)(src)),"c" ((long) (n)) \
-	:"di","si","cx"); \
+	:); \
 _res; \
 })
diff --git a/include/asm/segment.h b/include/asm/segment.h
index 9a643e0..e463266 100755
--- a/include/asm/segment.h
+++ b/include/asm/segment.h
@@ -1,4 +1,4 @@
-extern inline unsigned char get_fs_byte(const char * addr)
+static inline unsigned char get_fs_byte(const char * addr)
 {
 	unsigned register char _v;
 
@@ -6,7 +6,7 @@ extern inline unsigned char get_fs_byte(const char * addr)
 	return _v;
 }
 
-extern inline unsigned short get_fs_word(const unsigned short *addr)
+static inline unsigned short get_fs_word(const unsigned short *addr)
 {
 	unsigned short _v;
 
@@ -14,7 +14,7 @@ extern inline unsigned short get_fs_word(const unsigned short *addr)
 	return _v;
 }
 
-extern inline unsigned long get_fs_long(const unsigned long *addr)
+static inline unsigned long get_fs_long(const unsigned long *addr)
 {
 	unsigned long _v;
 
@@ -22,17 +22,17 @@ extern inline unsigned long get_fs_long(const unsigned long *addr)
 	return _v;
 }
 
-extern inline void put_fs_byte(char val,char *addr)
+static inline void put_fs_byte(char val,char *addr)
 {
 __asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
 }
 
-extern inline void put_fs_word(short val,short * addr)
+static inline void put_fs_word(short val,short * addr)
 {
 __asm__ ("movw %0,%%fs:%1"::"r" (val),"m" (*addr));
 }
 
-extern inline void put_fs_long(unsigned long val,unsigned long * addr)
+static inline void put_fs_long(unsigned long val,unsigned long * addr)
 {
 __asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
 }
@@ -44,21 +44,21 @@ __asm__ ("movl %0,%%fs:%1"::"r" (val),"m" (*addr));
  * [ nothing wrong here, Linus ]
  */
 
-extern inline unsigned long get_fs() 
+static inline unsigned long get_fs() 
 {
 	unsigned short _v;
 	__asm__("mov %%fs,%%ax":"=a" (_v):);
 	return _v;
 }
 
-extern inline unsigned long get_ds() 
+static inline unsigned long get_ds() 
 {
 	unsigned short _v;
 	__asm__("mov %%ds,%%ax":"=a" (_v):);
 	return _v;
 }
 
-extern inline void set_fs(unsigned long val)
+static inline void set_fs(unsigned long val)
 {
 	__asm__("mov %0,%%fs"::"a" ((unsigned short) val));
 }
diff --git a/include/string.h b/include/string.h
index 05eee8d..443bcf9 100755
--- a/include/string.h
+++ b/include/string.h
@@ -24,18 +24,19 @@ extern char * strerror(int errno);
  *		(C) 2019 VizXu
  */
  
-extern inline char * strcpy(char * dest,const char *src)
+static inline char * strcpy(char * dest,const char *src)
 {
-__asm__("cld\n"
+__asm__(
+	"cld\n"
 	"1:\tlodsb\n\t"
 	"stosb\n\t"
 	"testb %%al,%%al\n\t"
 	"jne 1b"
-	::"S" (src),"D" (dest):"si","di","ax");
+	::"S" (src),"D" (dest):"ax");
 return dest;
 }
 
-extern inline char * strncpy(char * dest,const char *src,int count)
+static inline char * strncpy(char * dest,const char *src,int count)
 {
 __asm__("cld\n"
 	"1:\tdecl %2\n\t"
@@ -47,11 +48,11 @@ __asm__("cld\n"
 	"rep\n\t"
 	"stosb\n"
 	"2:"
-	::"S" (src),"D" (dest),"c" (count):"si","di","ax","cx");
+	::"S" (src),"D" (dest),"c" (count):"ax");
 return dest;
 }
 
-extern inline char * strcat(char * dest,const char * src)
+static inline char * strcat(char * dest,const char * src)
 {
 __asm__("cld\n\t"
 	"repne\n\t"
@@ -61,11 +62,11 @@ __asm__("cld\n\t"
 	"stosb\n\t"
 	"testb %%al,%%al\n\t"
 	"jne 1b"
-	::"S" (src),"D" (dest),"a" (0),"c" (0xffffffff):"si","di","ax","cx");
+	::"S" (src),"D" (dest),"a" (0),"c" (0xffffffff):);
 return dest;
 }
 
-extern inline char * strncat(char * dest,const char * src,int count)
+static inline char * strncat(char * dest,const char * src,int count)
 {
 __asm__("cld\n\t"
 	"repne\n\t"
@@ -81,11 +82,11 @@ __asm__("cld\n\t"
 	"2:\txorl %2,%2\n\t"
 	"stosb"
 	::"S" (src),"D" (dest),"a" (0),"c" (0xffffffff),"g" (count)
-	:"si","di","ax","cx");
+	:);
 return dest;
 }
 
-extern inline int strcmp(const char * cs,const char * ct)
+static inline int strcmp(const char * cs,const char * ct)
 {
 register int __res __asm__("ax");
 __asm__("cld\n"
@@ -100,11 +101,11 @@ __asm__("cld\n"
 	"jl 3f\n\t"
 	"negl %%eax\n"
 	"3:"
-	:"=a" (__res):"D" (cs),"S" (ct):"si","di");
+	:"=a" (__res):"D" (cs),"S" (ct):);
 return __res;
 }
 
-extern inline int strncmp(const char * cs,const char * ct,int count)
+static inline int strncmp(const char * cs,const char * ct,int count)
 {
 register int __res __asm__("ax");
 __asm__("cld\n"
@@ -121,11 +122,11 @@ __asm__("cld\n"
 	"jl 4f\n\t"
 	"negl %%eax\n"
 	"4:"
-	:"=a" (__res):"D" (cs),"S" (ct),"c" (count):"si","di","cx");
+	:"=a" (__res):"D" (cs),"S" (ct),"c" (count):);
 return __res;
 }
 
-extern inline char * strchr(const char * s,char c)
+static inline char * strchr(const char * s,char c)
 {
 register char * __res __asm__("ax");
 __asm__("cld\n\t"
@@ -138,11 +139,11 @@ __asm__("cld\n\t"
 	"movl $1,%1\n"
 	"2:\tmovl %1,%0\n\t"
 	"decl %0"
-	:"=a" (__res):"S" (s),"0" (c):"si");
+	:"=a" (__res):"S" (s),"0" (c):);
 return __res;
 }
 
-extern inline char * strrchr(const char * s,char c)
+static inline char * strrchr(const char * s,char c)
 {
 register char * __res __asm__("dx");
 __asm__("cld\n\t"
@@ -154,11 +155,11 @@ __asm__("cld\n\t"
 	"decl %0\n"
 	"2:\ttestb %%al,%%al\n\t"
 	"jne 1b"
-	:"=d" (__res):"0" (0),"S" (s),"a" (c):"ax","si");
+	:"=d" (__res):"0" (0),"S" (s),"a" (c):);
 return __res;
 }
 
-extern inline int strspn(const char * cs, const char * ct)
+static inline int strspn(const char * cs, const char * ct)
 {
 register char * __res __asm__("si");
 __asm__("cld\n\t"
@@ -178,11 +179,11 @@ __asm__("cld\n\t"
 	"je 1b\n"
 	"2:\tdecl %0"
 	:"=S" (__res):"a" (0),"c" (0xffffffff),"0" (cs),"g" (ct)
-	:"ax","cx","dx","di");
+	:"dx","di");
 return __res-cs;
 }
 
-extern inline int strcspn(const char * cs, const char * ct)
+static inline int strcspn(const char * cs, const char * ct)
 {
 register char * __res __asm__("si");
 __asm__("cld\n\t"
@@ -202,11 +203,11 @@ __asm__("cld\n\t"
 	"jne 1b\n"
 	"2:\tdecl %0"
 	:"=S" (__res):"a" (0),"c" (0xffffffff),"0" (cs),"g" (ct)
-	:"ax","cx","dx","di");
+	:"dx","di");
 return __res-cs;
 }
 
-extern inline char * strpbrk(const char * cs,const char * ct)
+static inline char * strpbrk(const char * cs,const char * ct)
 {
 register char * __res __asm__("si");
 __asm__("cld\n\t"
@@ -229,11 +230,11 @@ __asm__("cld\n\t"
 	"2:\txorl %0,%0\n"
 	"3:"
 	:"=S" (__res):"a" (0),"c" (0xffffffff),"0" (cs),"g" (ct)
-	:"ax","cx","dx","di");
+	:"dx","di");
 return __res;
 }
 
-extern inline char * strstr(const char * cs,const char * ct)
+static inline char * strstr(const char * cs,const char * ct)
 {
 register char * __res __asm__("ax");
 __asm__("cld\n\t" \
@@ -256,11 +257,11 @@ __asm__("cld\n\t" \
 	"xorl %%eax,%%eax\n\t"
 	"2:"
 	:"=a" (__res):"0" (0),"c" (0xffffffff),"S" (cs),"g" (ct)
-	:"cx","dx","di","si");
+	:"dx","di");
 return __res;
 }
 
-extern inline int strlen(const char * s)
+static inline int strlen(const char * s)
 {
 register int __res __asm__("cx");
 __asm__("cld\n\t"
@@ -268,13 +269,13 @@ __asm__("cld\n\t"
 	"scasb\n\t"
 	"notl %0\n\t"
 	"decl %0"
-	:"=c" (__res):"D" (s),"a" (0),"0" (0xffffffff):"di");
+	:"=c" (__res):"D" (s),"a" (0),"0" (0xffffffff));
 return __res;
 }
 
-extern char * ___strtok;
+char * ___strtok;
 
-extern inline char * strtok(char * s,const char * ct)
+static inline char * strtok(char * s,const char * ct)
 {
 register char * __res __asm__("si");
 __asm__("testl %1,%1\n\t"
@@ -333,34 +334,34 @@ __asm__("testl %1,%1\n\t"
 return __res;
 }
 
-extern inline void * memcpy(void * dest,const void * src, int n)
+static inline void * memcpy(void * dest,const void * src, int n)
 {
 __asm__("cld\n\t"
 	"rep\n\t"
 	"movsb"
 	::"c" (n),"S" (src),"D" (dest)
-	:"cx","si","di");
+	:);
 return dest;
 }
 
-extern inline void * memmove(void * dest,const void * src, int n)
+static inline void * memmove(void * dest,const void * src, int n)
 {
 if (dest<src)
 __asm__("cld\n\t"
 	"rep\n\t"
 	"movsb"
 	::"c" (n),"S" (src),"D" (dest)
-	:"cx","si","di");
+	:);
 else
 __asm__("std\n\t"
 	"rep\n\t"
 	"movsb"
 	::"c" (n),"S" (src+n-1),"D" (dest+n-1)
-	:"cx","si","di");
+	:);
 return dest;
 }
 
-extern inline int memcmp(const void * cs,const void * ct,int count)
+static inline int memcmp(const void * cs,const void * ct,int count)
 {
 register int __res __asm__("ax");
 __asm__("cld\n\t"
@@ -372,11 +373,11 @@ __asm__("cld\n\t"
 	"negl %%eax\n"
 	"1:"
 	:"=a" (__res):"0" (0),"D" (cs),"S" (ct),"c" (count)
-	:"si","di","cx");
+	:);
 return __res;
 }
 
-extern inline void * memchr(const void * cs,char c,int count)
+static inline void * memchr(const void * cs,char c,int count)
 {
 register void * __res __asm__("di");
 if (!count)
@@ -388,17 +389,17 @@ __asm__("cld\n\t"
 	"movl $1,%0\n"
 	"1:\tdecl %0"
 	:"=D" (__res):"a" (c),"D" (cs),"c" (count)
-	:"cx");
+	:);
 return __res;
 }
 
-extern inline void * memset(void * s,char c,int count)
+static inline void * memset(void * s,char c,int count)
 {
 __asm__("cld\n\t"
 	"rep\n\t"
 	"stosb"
 	::"a" (c),"D" (s),"c" (count)
-	:"cx","di");
+	:);
 return s;
 }
 
diff --git a/include/viz/kernel.h b/include/viz/kernel.h
index 33fb0b8..546dcf7 100755
--- a/include/viz/kernel.h
+++ b/include/viz/kernel.h
@@ -21,6 +21,7 @@ extern int blankinterval;
 extern int blankcount;
 
 #define free(x) free_s((x), 0)
+#define LOG_INFO_TYPE       0
 
 /*
  * This is defined as a macro, but at some point this might become a
diff --git a/include/viz/mm.h b/include/viz/mm.h
index 632e138..5e02ac4 100755
--- a/include/viz/mm.h
+++ b/include/viz/mm.h
@@ -17,7 +17,7 @@ extern void free_page(unsigned long addr);
 void swap_free(int page_nr);
 void swap_in(unsigned long *table_ptr);
 
-extern inline volatile void oom(void)
+static inline volatile void oom(void)
 {
 	printk("out of memory\n\r");
 	do_exit(SIGSEGV);
diff --git a/include/viz/sched.h b/include/viz/sched.h
index c270a02..163b3d3 100755
--- a/include/viz/sched.h
+++ b/include/viz/sched.h
@@ -221,12 +221,12 @@ __asm__("str %%ax\n\t" \
  */
 #define switch_to(n) {\
 struct {long a,b;} __tmp; \
-__asm__("cmpl %%ecx,_current\n\t" \
+__asm__("cmpl %%ecx,current\n\t" \
 	"je 1f\n\t" \
 	"movw %%dx,%1\n\t" \
-	"xchgl %%ecx,_current\n\t" \
+	"xchgl %%ecx,current\n\t" \
 	"ljmp %0\n\t" \
-	"cmpl %%ecx,_last_task_used_math\n\t" \
+	"cmpl %%ecx,last_task_used_math\n\t" \
 	"jne 1f\n\t" \
 	"clts\n" \
 	"1:" \
@@ -245,7 +245,7 @@ __asm__("movw %%dx,%0\n\t" \
 	  "m" (*((addr)+4)), \
 	  "m" (*((addr)+7)), \
 	  "d" (base) \
-	:"dx")
+	:)
 
 #define _set_limit(addr,limit) \
 __asm__("movw %%dx,%0\n\t" \
@@ -257,7 +257,7 @@ __asm__("movw %%dx,%0\n\t" \
 	::"m" (*(addr)), \
 	  "m" (*((addr)+6)), \
 	  "d" (limit) \
-	:"dx")
+	:)
 
 #define set_base(ldt,base) _set_base( ((char *)&(ldt)) , base )
 #define set_limit(ldt,limit) _set_limit( ((char *)&(ldt)) , (limit-1)>>12 )
diff --git a/init/main.c b/init/main.c
index 04ca1cb..28f5ee1 100755
--- a/init/main.c
+++ b/init/main.c
@@ -20,10 +20,10 @@
  * won't be any messing with the stack from main(), but we define
  * some others too.
  */
-static inline _syscall0(int,fork)
-static inline _syscall0(int,pause)
-static inline _syscall1(int,setup,void *,BIOS)
-static inline _syscall0(int,sync)
+_syscall0(int,fork)
+_syscall0(int,pause)
+_syscall1(int,setup,void *,BIOS)
+_syscall0(int,sync)
 
 #include <viz/tty.h>
 #include <viz/sched.h>
@@ -54,6 +54,20 @@ extern void mem_init(long start, long end);
 extern long rd_init(long mem_start, int length);
 extern long kernel_mktime(struct tm * tm);
 
+
+static inline long fork_for_process0() {
+	long __res;
+	__asm__ volatile (
+		"int $0x80\n\t"  														
+		: "=a" (__res)  														
+		: "0" (2));  															
+	if (__res >= 0)  															
+		return __res;
+	errno = -__res;  														
+	return -1;
+}
+
+
 static int sprintf(char * str, const char *fmt, ...)
 {
 	va_list args;
@@ -162,7 +176,7 @@ void main(void)		/* This really IS void, no error here. */
 	floppy_init();
 	sti();
 	move_to_user_mode();
-	if (!fork()) {		/* we count on this going ok */
+	if (!fork_for_process0()) {		/* we count on this going ok */
 		init();
 	}
 /*
@@ -173,10 +187,10 @@ void main(void)		/* This really IS void, no error here. */
  * task can run, and if not we return here.
  */
 	for(;;)
-		__asm__("int $0x80"::"a" (__NR_pause):"ax");
+		__asm__("int $0x80"::"a" (__NR_pause):);
 }
 
-static int printf(const char *fmt, ...)
+int printf(const char *fmt, ...)
 {
 	va_list args;
 	int i;
diff --git a/kernel/Makefile b/kernel/Makefile
index d8f71b2..43dc5fa 100755
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -1,93 +1,93 @@
-#
-# Makefile for the FREAX-kernel.
-#
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
-
-AR	=gar
-AS	=gas
-LD	=gld
-LDFLAGS	=-s -x
-CC	=gcc
-CFLAGS	=-Wall -O -fstrength-reduce -fomit-frame-pointer -fcombine-regs \
-	-finline-functions -mstring-insns -nostdinc -I../include
-CPP	=gcc -E -nostdinc -I../include
-
-.c.s:
-	$(CC) $(CFLAGS) \
-	-S -o $*.s $<
-.s.o:
-	$(AS) -c -o $*.o $<
-.c.o:
-	$(CC) $(CFLAGS) \
-	-c -o $*.o $<
-
-OBJS  = sched.o sys_call.o traps.o asm.o fork.o \
-	panic.o printk.o vsprintf.o sys.o exit.o \
-	signal.o mktime.o
-
-kernel.o: $(OBJS)
-	$(LD) -r -o kernel.o $(OBJS)
-	sync
-
-clean:
-	rm -f core *.o *.a tmp_make keyboard.s
-	for i in *.c;do rm -f `basename $$i .c`.s;done
-	(cd chr_drv; make clean)
-	(cd blk_drv; make clean)
-	(cd math; make clean)
-
-dep:
-	sed '/\#\#\# Dependencies/q' < Makefile > tmp_make
-	(for i in *.c;do echo -n `echo $$i | sed 's,\.c,\.s,'`" "; \
-		$(CPP) -M $$i;done) >> tmp_make
-	cp tmp_make Makefile
-	(cd chr_drv; make dep)
-	(cd blk_drv; make dep)
-
-### Dependencies:
-exit.s exit.o : exit.c ../include/errno.h ../include/signal.h \
-  ../include/sys/types.h ../include/sys/wait.h ../include/viz/sched.h \
-  ../include/viz/head.h ../include/viz/fs.h ../include/viz/mm.h \
-  ../include/viz/kernel.h ../include/sys/param.h ../include/sys/time.h \
-  ../include/time.h ../include/sys/resource.h ../include/viz/tty.h \
-  ../include/termios.h ../include/asm/segment.h 
-fork.s fork.o : fork.c ../include/errno.h ../include/viz/sched.h \
-  ../include/viz/head.h ../include/viz/fs.h ../include/sys/types.h \
-  ../include/viz/mm.h ../include/viz/kernel.h ../include/signal.h \
-  ../include/sys/param.h ../include/sys/time.h ../include/time.h \
-  ../include/sys/resource.h ../include/asm/segment.h ../include/asm/system.h 
-mktime.s mktime.o : mktime.c ../include/time.h 
-panic.s panic.o : panic.c ../include/viz/kernel.h ../include/viz/sched.h \
-  ../include/viz/head.h ../include/viz/fs.h ../include/sys/types.h \
-  ../include/viz/mm.h ../include/signal.h ../include/sys/param.h \
-  ../include/sys/time.h ../include/time.h ../include/sys/resource.h 
-printk.s printk.o : printk.c ../include/stdarg.h ../include/stddef.h \
-  ../include/viz/kernel.h 
-sched.s sched.o : sched.c ../include/viz/sched.h ../include/viz/head.h \
-  ../include/viz/fs.h ../include/sys/types.h ../include/viz/mm.h \
-  ../include/viz/kernel.h ../include/signal.h ../include/sys/param.h \
-  ../include/sys/time.h ../include/time.h ../include/sys/resource.h \
-  ../include/viz/sys.h ../include/viz/fdreg.h ../include/asm/system.h \
-  ../include/asm/io.h ../include/asm/segment.h 
-signal.s signal.o : signal.c ../include/viz/sched.h ../include/viz/head.h \
-  ../include/viz/fs.h ../include/sys/types.h ../include/viz/mm.h \
-  ../include/viz/kernel.h ../include/signal.h ../include/sys/param.h \
-  ../include/sys/time.h ../include/time.h ../include/sys/resource.h \
-  ../include/asm/segment.h ../include/errno.h 
-sys.s sys.o : sys.c ../include/errno.h ../include/viz/sched.h \
-  ../include/viz/head.h ../include/viz/fs.h ../include/sys/types.h \
-  ../include/viz/mm.h ../include/viz/kernel.h ../include/signal.h \
-  ../include/sys/param.h ../include/sys/time.h ../include/time.h \
-  ../include/sys/resource.h ../include/viz/tty.h ../include/termios.h \
-  ../include/viz/config.h ../include/asm/segment.h ../include/sys/times.h \
-  ../include/sys/utsname.h ../include/string.h 
-traps.s traps.o : traps.c ../include/string.h ../include/viz/head.h \
-  ../include/viz/sched.h ../include/viz/fs.h ../include/sys/types.h \
-  ../include/viz/mm.h ../include/viz/kernel.h ../include/signal.h \
-  ../include/sys/param.h ../include/sys/time.h ../include/time.h \
-  ../include/sys/resource.h ../include/asm/system.h ../include/asm/segment.h \
-  ../include/asm/io.h 
-vsprintf.s vsprintf.o : vsprintf.c ../include/stdarg.h ../include/string.h 
+#
+# Makefile for the FREAX-kernel.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+include ../Makefile.header
+
+LDFLAGS	+= -r
+
+# NOTE!: do not try to add -On to CFLAGS with gcc4.x, which will optimize the
+# memcpy function a lot to let the kernel not work, for fixing this problem,
+# please refer to glibc and rewrite the memcpy in include/string.h, or just not
+# use any -On options with gcc 4.x when compiling it. in fact, we only can not
+# use -On with gcc4.x to compile fork.c, but after that you need to isolate the
+# compling procedure of it, it's not good too. for playing with viz-0.11, we
+# just have fun, have no much concerning about the performance.
+
+CFLAGS	+= -finline-functions -nostdinc -I../include	
+CPP	+= -I../include
+
+.c.s:
+	@$(CC) $(CFLAGS) \
+	-S -o $*.s $<
+.s.o:
+	@$(AS) -o $*.o $<
+.c.o:
+	@$(CC) $(CFLAGS) \
+	-c -o $*.o $<
+
+OBJS  = sched.o sys_call.o traps.o asm.o fork.o panic.o printk.o vsprintf.o sys.o exit.o signal.o mktime.o
+	#sched.o sys_call.o traps.o asm.o fork.o panic.o printk.o vsprintf.o sys.o exit.o signal.o mktime.o	
+kernel.o: $(OBJS)
+	@$(LD) $(LDFLAGS) -o kernel.o $(OBJS)
+	@sync
+
+clean:
+	@rm -f core *.o *.a tmp_make keyboard.s
+	@for i in *.c;do rm -f `basename $$i .c`.s;done
+	@for i in chr_drv blk_drv math; do make clean -C $$i; done
+
+dep:
+	@sed '/\#\#\# Dependencies/q' < Makefile > tmp_make
+	@(for i in *.c;do echo -n `echo $$i | sed 's,\.c,\.s,'`" "; \
+		$(CPP) -M $$i;done) >> tmp_make
+	@cp tmp_make Makefile
+	@for i in chr_drv blk_drv math; do make dep -C $$i; done
+
+### Dependencies:
+exit.s exit.o: exit.c ../include/errno.h ../include/signal.h \
+ ../include/sys/types.h ../include/sys/wait.h ../include/viz/sched.h \
+ ../include/viz/head.h ../include/viz/fs.h ../include/viz/mm.h \
+ ../include/viz/kernel.h ../include/sys/param.h ../include/sys/time.h \
+ ../include/time.h ../include/sys/resource.h ../include/viz/tty.h \
+ ../include/termios.h ../include/asm/segment.h
+fork.s fork.o: fork.c ../include/errno.h ../include/viz/sched.h \
+ ../include/viz/head.h ../include/viz/fs.h ../include/sys/types.h \
+ ../include/viz/mm.h ../include/viz/kernel.h ../include/signal.h \
+ ../include/sys/param.h ../include/sys/time.h ../include/time.h \
+ ../include/sys/resource.h ../include/asm/system.h
+mktime.s mktime.o: mktime.c ../include/time.h
+panic.s panic.o: panic.c ../include/viz/kernel.h ../include/viz/sched.h \
+ ../include/viz/head.h ../include/viz/fs.h ../include/sys/types.h \
+ ../include/viz/mm.h ../include/signal.h ../include/sys/param.h \
+ ../include/sys/time.h ../include/time.h ../include/sys/resource.h
+printk.s printk.o: printk.c ../include/stdarg.h ../include/stddef.h \
+ ../include/viz/kernel.h
+sched.s sched.o: sched.c ../include/viz/sched.h ../include/viz/head.h \
+ ../include/viz/fs.h ../include/sys/types.h ../include/viz/mm.h \
+ ../include/viz/kernel.h ../include/signal.h ../include/sys/param.h \
+ ../include/sys/time.h ../include/time.h ../include/sys/resource.h \
+ ../include/viz/sys.h ../include/viz/fdreg.h ../include/asm/system.h \
+ ../include/asm/io.h
+signal.s signal.o: signal.c ../include/viz/sched.h ../include/viz/head.h \
+ ../include/viz/fs.h ../include/sys/types.h ../include/viz/mm.h \
+ ../include/viz/kernel.h ../include/signal.h ../include/sys/param.h \
+ ../include/sys/time.h ../include/time.h ../include/sys/resource.h \
+ ../include/asm/segment.h ../include/errno.h
+sys.s sys.o: sys.c ../include/errno.h ../include/viz/sched.h \
+ ../include/viz/head.h ../include/viz/fs.h ../include/sys/types.h \
+ ../include/viz/mm.h ../include/viz/kernel.h ../include/signal.h \
+ ../include/sys/param.h ../include/sys/time.h ../include/time.h \
+ ../include/sys/resource.h ../include/viz/config.h \
+ ../include/asm/segment.h ../include/sys/times.h ../include/sys/utsname.h \
+ ../include/string.h
+traps.s traps.o: traps.c ../include/viz/head.h ../include/viz/sched.h \
+ ../include/viz/fs.h ../include/sys/types.h ../include/viz/mm.h \
+ ../include/viz/kernel.h ../include/signal.h ../include/sys/param.h \
+ ../include/sys/time.h ../include/time.h ../include/sys/resource.h \
+ ../include/asm/system.h ../include/asm/segment.h ../include/asm/io.h
+vsprintf.s vsprintf.o: vsprintf.c ../include/stdarg.h ../include/string.h
diff --git a/kernel/blk_drv/Makefile b/kernel/blk_drv/Makefile
index 1f8e681..69f96b1 100755
--- a/kernel/blk_drv/Makefile
+++ b/kernel/blk_drv/Makefile
@@ -1,71 +1,67 @@
-#
-# Makefile for the FREAX-kernel block device drivers.
-#
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
-
-AR	=gar
-AS	=gas
-LD	=gld
-LDFLAGS	=-s -x
-CC	=gcc
-CFLAGS	=-Wall -O -fstrength-reduce -fomit-frame-pointer -fcombine-regs \
-	-finline-functions -mstring-insns -nostdinc -I../../include
-CPP	=gcc -E -nostdinc -I../../include
-
-.c.s:
-	$(CC) $(CFLAGS) \
-	-S -o $*.s $<
-.s.o:
-	$(AS) -c -o $*.o $<
-.c.o:
-	$(CC) $(CFLAGS) \
-	-c -o $*.o $<
-
-OBJS  = ll_rw_blk.o floppy.o hd.o ramdisk.o
-
-blk_drv.a: $(OBJS)
-	$(AR) rcs blk_drv.a $(OBJS)
-	sync
-
-clean:
-	rm -f core *.o *.a tmp_make
-	for i in *.c;do rm -f `basename $$i .c`.s;done
-
-dep:
-	sed '/\#\#\# Dependencies/q' < Makefile > tmp_make
-	(for i in *.c;do echo -n `echo $$i | sed 's,\.c,\.s,'`" "; \
-		$(CPP) -M $$i;done) >> tmp_make
-	cp tmp_make Makefile
-
-### Dependencies:
-floppy.s floppy.o : floppy.c ../../include/viz/sched.h ../../include/viz/head.h \
-  ../../include/viz/fs.h ../../include/sys/types.h ../../include/viz/mm.h \
-  ../../include/viz/kernel.h ../../include/signal.h \
-  ../../include/sys/param.h ../../include/sys/time.h ../../include/time.h \
-  ../../include/sys/resource.h ../../include/viz/fdreg.h \
-  ../../include/asm/system.h ../../include/asm/io.h \
-  ../../include/asm/segment.h blk.h 
-hd.s hd.o : hd.c ../../include/viz/config.h ../../include/viz/sched.h \
-  ../../include/viz/head.h ../../include/viz/fs.h \
-  ../../include/sys/types.h ../../include/viz/mm.h \
-  ../../include/viz/kernel.h ../../include/signal.h \
-  ../../include/sys/param.h ../../include/sys/time.h ../../include/time.h \
-  ../../include/sys/resource.h ../../include/viz/hdreg.h \
-  ../../include/asm/system.h ../../include/asm/io.h \
-  ../../include/asm/segment.h blk.h 
-ll_rw_blk.s ll_rw_blk.o : ll_rw_blk.c ../../include/errno.h ../../include/viz/sched.h \
-  ../../include/viz/head.h ../../include/viz/fs.h \
-  ../../include/sys/types.h ../../include/viz/mm.h \
-  ../../include/viz/kernel.h ../../include/signal.h \
-  ../../include/sys/param.h ../../include/sys/time.h ../../include/time.h \
-  ../../include/sys/resource.h ../../include/asm/system.h blk.h 
-ramdisk.s ramdisk.o : ramdisk.c ../../include/string.h ../../include/viz/config.h \
-  ../../include/viz/sched.h ../../include/viz/head.h \
-  ../../include/viz/fs.h ../../include/sys/types.h ../../include/viz/mm.h \
-  ../../include/viz/kernel.h ../../include/signal.h \
-  ../../include/sys/param.h ../../include/sys/time.h ../../include/time.h \
-  ../../include/sys/resource.h ../../include/asm/system.h \
-  ../../include/asm/segment.h ../../include/asm/memory.h blk.h 
+#
+# Makefile for the FREAX-kernel block device drivers.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+include ../../Makefile.header
+
+CFLAGS	+= -finline-functions -nostdinc -I../../include
+CPP	+= -I../../include
+
+.c.s:
+	@$(CC) $(CFLAGS) \
+	-S -o $*.s $<
+.s.o:
+	@$(AS) -o $*.o $<
+.c.o:
+	@$(CC) $(CFLAGS) \
+	-c -o $*.o $<
+
+OBJS  = ll_rw_blk.o floppy.o hd.o ramdisk.o
+	# ll_rw_blk.o floppy.o hd.o ramdisk.o
+blk_drv.a: $(OBJS)
+	@$(AR) rcs blk_drv.a $(OBJS)
+	@sync
+
+clean:
+	@rm -f core *.o *.a tmp_make
+	@for i in *.c;do rm -f `basename $$i .c`.s;done
+
+dep:
+	@sed '/\#\#\# Dependencies/q' < Makefile > tmp_make
+	@(for i in *.c;do echo -n `echo $$i | sed 's,\.c,\.s,'`" "; \
+		$(CPP) -M $$i;done) >> tmp_make
+	@cp tmp_make Makefile
+
+### Dependencies:
+floppy.s floppy.o: floppy.c ../../include/viz/sched.h ../../include/viz/head.h \
+ ../../include/viz/fs.h ../../include/sys/types.h \
+ ../../include/viz/mm.h ../../include/viz/kernel.h \
+ ../../include/signal.h ../../include/sys/param.h \
+ ../../include/sys/time.h ../../include/time.h \
+ ../../include/sys/resource.h ../../include/viz/fdreg.h \
+ ../../include/asm/system.h ../../include/asm/io.h \
+ ../../include/asm/segment.h blk.h
+hd.s hd.o: hd.c ../../include/viz/config.h ../../include/viz/sched.h \
+ ../../include/viz/head.h ../../include/viz/fs.h \
+ ../../include/sys/types.h ../../include/viz/mm.h \
+ ../../include/viz/kernel.h ../../include/signal.h \
+ ../../include/sys/param.h ../../include/sys/time.h ../../include/time.h \
+ ../../include/sys/resource.h ../../include/viz/hdreg.h \
+ ../../include/asm/system.h ../../include/asm/io.h blk.h
+ll_rw_blk.s ll_rw_blk.o: ll_rw_blk.c ../../include/errno.h \
+ ../../include/viz/sched.h ../../include/viz/head.h \
+ ../../include/viz/fs.h ../../include/sys/types.h \
+ ../../include/viz/mm.h ../../include/viz/kernel.h \
+ ../../include/signal.h ../../include/sys/param.h \
+ ../../include/sys/time.h ../../include/time.h \
+ ../../include/sys/resource.h ../../include/asm/system.h blk.h
+ramdisk.s ramdisk.o: ramdisk.c ../../include/string.h ../../include/viz/fs.h \
+ ../../include/sys/types.h blk.h ../../include/viz/kernel.h \
+ ../../include/viz/sched.h ../../include/viz/head.h \
+ ../../include/viz/mm.h ../../include/signal.h \
+ ../../include/sys/param.h ../../include/sys/time.h ../../include/time.h \
+ ../../include/sys/resource.h
diff --git a/kernel/blk_drv/blk.h b/kernel/blk_drv/blk.h
index 54774a1..0221d57 100755
--- a/kernel/blk_drv/blk.h
+++ b/kernel/blk_drv/blk.h
@@ -107,7 +107,7 @@ int DEVICE_TIMEOUT = 0;
 #endif
 static void (DEVICE_REQUEST)(void);
 
-extern inline void unlock_buffer(struct buffer_head * bh)
+static inline void unlock_buffer(struct buffer_head * bh)
 {
 	if (!bh->b_lock)
 		printk(DEVICE_NAME ": free buffer being unlocked\n");
@@ -115,7 +115,7 @@ extern inline void unlock_buffer(struct buffer_head * bh)
 	wake_up(&bh->b_wait);
 }
 
-extern inline void end_request(int uptodate)
+static inline void end_request(int uptodate)
 {
 	DEVICE_OFF(CURRENT->dev);
 	if (CURRENT->bh) {
diff --git a/kernel/blk_drv/floppy.c b/kernel/blk_drv/floppy.c
index ecb86dd..f122438 100755
--- a/kernel/blk_drv/floppy.c
+++ b/kernel/blk_drv/floppy.c
@@ -130,7 +130,7 @@ repeat:
 #define copy_buffer(from,to) \
 __asm__("cld ; rep ; movsl" \
 	::"c" (BLOCK_SIZE/4),"S" ((long)(from)),"D" ((long)(to)) \
-	:"cx","di","si")
+	:)
 
 static void setup_DMA(void)
 {
diff --git a/kernel/blk_drv/hd.c b/kernel/blk_drv/hd.c
index 2133cf2..71b5c8f 100755
--- a/kernel/blk_drv/hd.c
+++ b/kernel/blk_drv/hd.c
@@ -62,10 +62,10 @@ static struct hd_struct {
 static int hd_sizes[5*MAX_HD] = {0, };
 
 #define port_read(port,buf,nr) \
-__asm__("cld;rep;insw"::"d" (port),"D" (buf),"c" (nr):"cx","di")
+__asm__("cld;rep;insw"::"d" (port),"D" (buf),"c" (nr):)
 
 #define port_write(port,buf,nr) \
-__asm__("cld;rep;outsw"::"d" (port),"S" (buf),"c" (nr):"cx","si")
+__asm__("cld;rep;outsw"::"d" (port),"S" (buf),"c" (nr):)
 
 extern void hd_interrupt(void);
 extern void rd_load(void);
diff --git a/kernel/chr_drv/Makefile b/kernel/chr_drv/Makefile
index de33350..870eab8 100755
--- a/kernel/chr_drv/Makefile
+++ b/kernel/chr_drv/Makefile
@@ -1,88 +1,87 @@
-#
-# Makefile for the FREAX-kernel character device drivers.
-#
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
-
-AR	=gar
-AS	=gas
-LD	=gld
-LDFLAGS	=-s -x
-CC	=gcc
-CFLAGS	=-Wall -O -fstrength-reduce -fomit-frame-pointer -fcombine-regs \
-	-finline-functions -mstring-insns -nostdinc -I../../include
-CPP	=gcc -E -nostdinc -I../../include
-
-.c.s:
-	$(CC) $(CFLAGS) \
-	-S -o $*.s $<
-.s.o:
-	$(AS) -c -o $*.o $<
-.c.o:
-	$(CC) $(CFLAGS) \
-	-c -o $*.o $<
-
-OBJS  = tty_io.o console.o keyboard.o serial.o rs_io.o \
-	tty_ioctl.o pty.o
-
-chr_drv.a: $(OBJS)
-	$(AR) rcs chr_drv.a $(OBJS)
-	sync
-
-keyboard.s: keyboard.S
-	$(CPP) -traditional keyboard.S -o keyboard.s
-
-clean:
-	rm -f core *.o *.a tmp_make keyboard.s
-	for i in *.c;do rm -f `basename $$i .c`.s;done
-
-dep:
-	sed '/\#\#\# Dependencies/q' < Makefile > tmp_make
-	(for i in *.c;do echo -n `echo $$i | sed 's,\.c,\.s,'`" "; \
-		$(CPP) -M $$i;done) >> tmp_make
-	cp tmp_make Makefile
-
-### Dependencies:
-console.s console.o : console.c ../../include/viz/sched.h \
-  ../../include/viz/head.h ../../include/viz/fs.h \
-  ../../include/sys/types.h ../../include/viz/mm.h \
-  ../../include/viz/kernel.h ../../include/signal.h \
-  ../../include/sys/param.h ../../include/sys/time.h ../../include/time.h \
-  ../../include/sys/resource.h ../../include/viz/tty.h \
-  ../../include/termios.h ../../include/viz/config.h ../../include/asm/io.h \
-  ../../include/asm/system.h ../../include/asm/segment.h \
-  ../../include/string.h ../../include/errno.h 
-pty.s pty.o : pty.c ../../include/viz/tty.h ../../include/termios.h \
-  ../../include/sys/types.h ../../include/viz/sched.h \
-  ../../include/viz/head.h ../../include/viz/fs.h \
-  ../../include/viz/mm.h ../../include/viz/kernel.h \
-  ../../include/signal.h ../../include/sys/param.h ../../include/sys/time.h \
-  ../../include/time.h ../../include/sys/resource.h \
-  ../../include/asm/system.h ../../include/asm/io.h 
-serial.s serial.o : serial.c ../../include/viz/tty.h ../../include/termios.h \
-  ../../include/sys/types.h ../../include/viz/sched.h \
-  ../../include/viz/head.h ../../include/viz/fs.h \
-  ../../include/viz/mm.h ../../include/viz/kernel.h \
-  ../../include/signal.h ../../include/sys/param.h ../../include/sys/time.h \
-  ../../include/time.h ../../include/sys/resource.h \
-  ../../include/asm/system.h ../../include/asm/io.h 
-tty_io.s tty_io.o : tty_io.c ../../include/ctype.h ../../include/errno.h \
-  ../../include/signal.h ../../include/sys/types.h ../../include/unistd.h \
-  ../../include/sys/stat.h ../../include/sys/time.h ../../include/time.h \
-  ../../include/sys/times.h ../../include/sys/utsname.h \
-  ../../include/sys/param.h ../../include/sys/resource.h \
-  ../../include/utime.h ../../include/viz/sched.h \
-  ../../include/viz/head.h ../../include/viz/fs.h \
-  ../../include/viz/mm.h ../../include/viz/kernel.h \
-  ../../include/viz/tty.h ../../include/termios.h \
-  ../../include/asm/segment.h ../../include/asm/system.h 
-tty_ioctl.s tty_ioctl.o : tty_ioctl.c ../../include/errno.h ../../include/termios.h \
-  ../../include/sys/types.h ../../include/viz/sched.h \
-  ../../include/viz/head.h ../../include/viz/fs.h \
-  ../../include/viz/mm.h ../../include/viz/kernel.h \
-  ../../include/signal.h ../../include/sys/param.h ../../include/sys/time.h \
-  ../../include/time.h ../../include/sys/resource.h ../../include/viz/tty.h \
-  ../../include/asm/io.h ../../include/asm/segment.h \
-  ../../include/asm/system.h 
+#
+# Makefile for the FREAX-kernel character device drivers.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+include ../../Makefile.header
+
+CFLAGS	+= -finline-functions -nostdinc -I../../include
+CPP_DISPLAY	+= -I../../include
+CPP += -I../../include
+
+.c.s:
+	@$(CC) $(CFLAGS) \
+	-S -o $*.s $<
+.s.o:
+	@$(AS) -o $*.o $<
+.c.o:
+	@$(CC) $(CFLAGS) \
+	-c -o $*.o $<
+
+OBJS  = tty_io.o console.o keyboard.o serial.o rs_io.o \
+	tty_ioctl.o pty.o
+chr_drv.a: $(OBJS)
+	@$(AR) rcs chr_drv.a $(OBJS)
+	@sync
+	
+keyboard.s: keyboard.S ../../include/viz/config.h
+	$(CPP_DISPLAY) -traditional keyboard.S -o keyboard.s
+	
+clean:
+	@rm -f core *.o *.a tmp_make keyboard.s
+	@for i in *.c;do rm -f `basename $$i .c`.s;done
+
+dep:
+	@sed '/\#\#\# Dependencies/q' < Makefile > tmp_make
+	@(for i in *.c;do echo -n `echo $$i | sed 's,\.c,\.s,'`" "; \
+		$(CPP) -M $$i;done) >> tmp_make
+	@cp tmp_make Makefile
+
+### Dependencies:
+console.s console.o: console.c ../../include/viz/sched.h \
+ ../../include/viz/head.h ../../include/viz/fs.h \
+ ../../include/sys/types.h ../../include/viz/mm.h \
+ ../../include/viz/kernel.h ../../include/signal.h \
+ ../../include/sys/param.h ../../include/sys/time.h ../../include/time.h \
+ ../../include/sys/resource.h ../../include/viz/tty.h \
+ ../../include/termios.h ../../include/asm/io.h \
+ ../../include/asm/system.h ../../include/asm/segment.h \
+ ../../include/errno.h
+pty.s pty.o: pty.c ../../include/viz/tty.h ../../include/termios.h \
+ ../../include/sys/types.h ../../include/viz/sched.h \
+ ../../include/viz/head.h ../../include/viz/fs.h \
+ ../../include/viz/mm.h ../../include/viz/kernel.h \
+ ../../include/signal.h ../../include/sys/param.h \
+ ../../include/sys/time.h ../../include/time.h \
+ ../../include/sys/resource.h ../../include/asm/system.h \
+ ../../include/asm/io.h
+serial.s serial.o: serial.c ../../include/viz/tty.h ../../include/termios.h \
+ ../../include/sys/types.h ../../include/viz/sched.h \
+ ../../include/viz/head.h ../../include/viz/fs.h \
+ ../../include/viz/mm.h ../../include/viz/kernel.h \
+ ../../include/signal.h ../../include/sys/param.h \
+ ../../include/sys/time.h ../../include/time.h \
+ ../../include/sys/resource.h ../../include/asm/system.h \
+ ../../include/asm/io.h
+tty_io.s tty_io.o: tty_io.c ../../include/ctype.h ../../include/errno.h \
+ ../../include/signal.h ../../include/sys/types.h ../../include/unistd.h \
+ ../../include/sys/stat.h ../../include/sys/time.h ../../include/time.h \
+ ../../include/sys/times.h ../../include/sys/utsname.h \
+ ../../include/sys/param.h ../../include/sys/resource.h \
+ ../../include/utime.h ../../include/viz/sched.h \
+ ../../include/viz/head.h ../../include/viz/fs.h \
+ ../../include/viz/mm.h ../../include/viz/kernel.h \
+ ../../include/viz/tty.h ../../include/termios.h \
+ ../../include/asm/segment.h ../../include/asm/system.h
+tty_ioctl.s tty_ioctl.o: tty_ioctl.c ../../include/errno.h ../../include/termios.h \
+ ../../include/sys/types.h ../../include/viz/sched.h \
+ ../../include/viz/head.h ../../include/viz/fs.h \
+ ../../include/viz/mm.h ../../include/viz/kernel.h \
+ ../../include/signal.h ../../include/sys/param.h \
+ ../../include/sys/time.h ../../include/time.h \
+ ../../include/sys/resource.h ../../include/viz/tty.h \
+ ../../include/asm/io.h ../../include/asm/segment.h \
+ ../../include/asm/system.h
diff --git a/kernel/chr_drv/console.c b/kernel/chr_drv/console.c
index aec45f5..7864a62 100755
--- a/kernel/chr_drv/console.c
+++ b/kernel/chr_drv/console.c
@@ -206,7 +206,7 @@ static void scrup(int currcons)
 					"c" ((video_num_lines-1)*video_num_columns>>1),
 					"D" (video_mem_start),
 					"S" (origin)
-					:"cx","di","si");
+					:);
 				scr_end -= origin-video_mem_start;
 				pos -= origin-video_mem_start;
 				origin = video_mem_start;
@@ -217,7 +217,7 @@ static void scrup(int currcons)
 					::"a" (video_erase_char),
 					"c" (video_num_columns),
 					"D" (scr_end-video_size_row)
-					:"cx","di");
+					:);
 			}
 			set_origin(currcons);
 		} else {
@@ -231,7 +231,7 @@ static void scrup(int currcons)
 				"c" ((bottom-top-1)*video_num_columns>>1),
 				"D" (origin+video_size_row*top),
 				"S" (origin+video_size_row*(top+1))
-				:"cx","di","si");
+				:);
 		}
 	}
 	else		/* Not EGA/VGA */
@@ -246,7 +246,7 @@ static void scrup(int currcons)
 			"c" ((bottom-top-1)*video_num_columns>>1),
 			"D" (origin+video_size_row*top),
 			"S" (origin+video_size_row*(top+1))
-			:"cx","di","si");
+			:);
 	}
 }
 
@@ -267,7 +267,7 @@ static void scrdown(int currcons)
 			"c" ((bottom-top-1)*video_num_columns>>1),
 			"D" (origin+video_size_row*bottom-4),
 			"S" (origin+video_size_row*(bottom-1)-4)
-			:"ax","cx","di","si");
+			:);
 	}
 	else		/* Not EGA/VGA */
 	{
@@ -282,7 +282,7 @@ static void scrdown(int currcons)
 			"c" ((bottom-top-1)*video_num_columns>>1),
 			"D" (origin+video_size_row*bottom-4),
 			"S" (origin+video_size_row*(bottom-1)-4)
-			:"ax","cx","di","si");
+			:);
 	}
 }
 
@@ -347,7 +347,7 @@ static void csi_J(int currcons, int vpar)
 		"stosw\n\t"
 		::"c" (count),
 		"D" (start),"a" (video_erase_char)
-		:"cx","di");
+		:);
 }
 
 static void csi_K(int currcons, int vpar)
@@ -378,7 +378,7 @@ static void csi_K(int currcons, int vpar)
 		"stosw\n\t"
 		::"c" (count),
 		"D" (start),"a" (video_erase_char)
-		:"cx","di");
+		:);
 }
 
 void csi_m(int currcons )
@@ -601,7 +601,7 @@ void con_write(struct tty_struct * tty)
 						::"a" (translate[c-32]),
 						"m" (*(short *)pos),
 						"m" (attr)
-						:"ax");
+						:);
 					pos += 2;
 					x++;
 				} else if (c==27)
@@ -1017,7 +1017,7 @@ void console_print(const char * b)
 			::"a" (c),
 			"m" (*(short *)pos),
 			"m" (attr)
-			:"ax");
+			:);
 		pos += 2;
 		x++;
 	}
diff --git a/kernel/math/Makefile b/kernel/math/Makefile
index 7175693..bd71580 100755
--- a/kernel/math/Makefile
+++ b/kernel/math/Makefile
@@ -1,83 +1,101 @@
-#
-# Makefile for the FREAX-kernel character device drivers.
-#
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
-
-AR	=gar
-AS	=gas
-LD	=gld
-LDFLAGS	=-s -x
-CC	=gcc
-CFLAGS	=-Wall -O -fstrength-reduce -fomit-frame-pointer -fcombine-regs \
-	-finline-functions -mstring-insns -nostdinc -I../../include
-CPP	=gcc -E -nostdinc -I../../include
-
-.c.s:
-	$(CC) $(CFLAGS) \
-	-S -o $*.s $<
-.s.o:
-	$(AS) -c -o $*.o $<
-.c.o:
-	$(CC) $(CFLAGS) \
-	-c -o $*.o $<
-
-OBJS  = math_emulate.o error.o convert.o ea.o get_put.o \
-	add.o mul.o div.o compare.o
-
-math.a: $(OBJS)
-	$(AR) rcs math.a $(OBJS)
-	sync
-
-clean:
-	rm -f core *.o *.a tmp_make
-	for i in *.c;do rm -f `basename $$i .c`.s;done
-
-dep:
-	sed '/\#\#\# Dependencies/q' < Makefile > tmp_make
-	(for i in *.c;do echo -n `echo $$i | sed 's,\.c,\.s,'`" "; \
-		$(CPP) -M $$i;done) >> tmp_make
-	cp tmp_make Makefile
-
-### Dependencies:
-add.s add.o : add.c ../../include/viz/math_emu.h ../../include/viz/sched.h \
-  ../../include/viz/head.h ../../include/viz/fs.h \
-  ../../include/sys/types.h ../../include/viz/mm.h \
-  ../../include/viz/kernel.h ../../include/signal.h 
-compare.s compare.o : compare.c ../../include/viz/math_emu.h \
-  ../../include/viz/sched.h ../../include/viz/head.h \
-  ../../include/viz/fs.h ../../include/sys/types.h ../../include/viz/mm.h \
-  ../../include/viz/kernel.h ../../include/signal.h 
-convert.s convert.o : convert.c ../../include/viz/math_emu.h \
-  ../../include/viz/sched.h ../../include/viz/head.h \
-  ../../include/viz/fs.h ../../include/sys/types.h ../../include/viz/mm.h \
-  ../../include/viz/kernel.h ../../include/signal.h 
-div.s div.o : div.c ../../include/viz/math_emu.h ../../include/viz/sched.h \
-  ../../include/viz/head.h ../../include/viz/fs.h \
-  ../../include/sys/types.h ../../include/viz/mm.h \
-  ../../include/viz/kernel.h ../../include/signal.h 
-ea.s ea.o : ea.c ../../include/stddef.h ../../include/viz/math_emu.h \
-  ../../include/viz/sched.h ../../include/viz/head.h \
-  ../../include/viz/fs.h ../../include/sys/types.h ../../include/viz/mm.h \
-  ../../include/viz/kernel.h ../../include/signal.h \
-  ../../include/asm/segment.h 
-error.s error.o : error.c ../../include/signal.h ../../include/sys/types.h \
-  ../../include/viz/sched.h ../../include/viz/head.h \
-  ../../include/viz/fs.h ../../include/viz/mm.h \
-  ../../include/viz/kernel.h 
-get_put.s get_put.o : get_put.c ../../include/signal.h ../../include/sys/types.h \
-  ../../include/viz/math_emu.h ../../include/viz/sched.h \
-  ../../include/viz/head.h ../../include/viz/fs.h \
-  ../../include/viz/mm.h ../../include/viz/kernel.h \
-  ../../include/asm/segment.h 
-math_emulate.s math_emulate.o : math_emulate.c ../../include/signal.h \
-  ../../include/sys/types.h ../../include/viz/math_emu.h \
-  ../../include/viz/sched.h ../../include/viz/head.h \
-  ../../include/viz/fs.h ../../include/viz/mm.h \
-  ../../include/viz/kernel.h ../../include/asm/segment.h 
-mul.s mul.o : mul.c ../../include/viz/math_emu.h ../../include/viz/sched.h \
-  ../../include/viz/head.h ../../include/viz/fs.h \
-  ../../include/sys/types.h ../../include/viz/mm.h \
-  ../../include/viz/kernel.h ../../include/signal.h 
+#
+# Makefile for the FREAX-kernel character device drivers.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+include ../../Makefile.header
+
+CFLAGS	+= -finline-functions -nostdinc -I../../include
+CPP	+= -I../../include
+
+.c.s:
+	@$(CC) $(CFLAGS) \
+	-S -o $*.s $<
+.s.o:
+	@$(AS) -o $*.o $<
+.c.o:
+	@$(CC) $(CFLAGS) \
+	-c -o $*.o $<
+
+OBJS  = math_emulate.o error.o convert.o ea.o get_put.o \
+	add.o mul.o div.o compare.o
+#OBJS  = math_emulate.o error.o convert.o ea.o get_put.o \
+#	add.o mul.o div.o compare.o
+
+math.a: $(OBJS)
+	@$(AR) rcs math.a $(OBJS)
+	@sync
+
+clean:
+	@rm -f core *.o *.a tmp_make
+	@for i in *.c;do rm -f `basename $$i .c`.s;done
+
+dep:
+	@sed '/\#\#\# Dependencies/q' < Makefile > tmp_make
+	@(for i in *.c;do echo -n `echo $$i | sed 's,\.c,\.s,'`" "; \
+		$(CPP) -M $$i;done) >> tmp_make
+	@cp tmp_make Makefile
+
+### Dependencies:
+add.s add.o: add.c ../../include/viz/math_emu.h ../../include/viz/sched.h \
+ ../../include/viz/head.h ../../include/viz/fs.h \
+ ../../include/sys/types.h ../../include/viz/mm.h \
+ ../../include/viz/kernel.h ../../include/signal.h \
+ ../../include/sys/param.h ../../include/sys/time.h ../../include/time.h \
+ ../../include/sys/resource.h
+compare.s compare.o: compare.c ../../include/viz/math_emu.h \
+ ../../include/viz/sched.h ../../include/viz/head.h \
+ ../../include/viz/fs.h ../../include/sys/types.h \
+ ../../include/viz/mm.h ../../include/viz/kernel.h \
+ ../../include/signal.h ../../include/sys/param.h \
+ ../../include/sys/time.h ../../include/time.h \
+ ../../include/sys/resource.h
+convert.s convert.o: convert.c ../../include/viz/math_emu.h \
+ ../../include/viz/sched.h ../../include/viz/head.h \
+ ../../include/viz/fs.h ../../include/sys/types.h \
+ ../../include/viz/mm.h ../../include/viz/kernel.h \
+ ../../include/signal.h ../../include/sys/param.h \
+ ../../include/sys/time.h ../../include/time.h \
+ ../../include/sys/resource.h
+div.s div.o: div.c ../../include/viz/math_emu.h ../../include/viz/sched.h \
+ ../../include/viz/head.h ../../include/viz/fs.h \
+ ../../include/sys/types.h ../../include/viz/mm.h \
+ ../../include/viz/kernel.h ../../include/signal.h \
+ ../../include/sys/param.h ../../include/sys/time.h ../../include/time.h \
+ ../../include/sys/resource.h
+ea.s ea.o: ea.c ../../include/stddef.h ../../include/viz/math_emu.h \
+ ../../include/viz/sched.h ../../include/viz/head.h \
+ ../../include/viz/fs.h ../../include/sys/types.h \
+ ../../include/viz/mm.h ../../include/viz/kernel.h \
+ ../../include/signal.h ../../include/sys/param.h \
+ ../../include/sys/time.h ../../include/time.h \
+ ../../include/sys/resource.h ../../include/asm/segment.h
+error.s error.o: error.c ../../include/signal.h ../../include/sys/types.h \
+ ../../include/viz/sched.h ../../include/viz/head.h \
+ ../../include/viz/fs.h ../../include/viz/mm.h \
+ ../../include/viz/kernel.h ../../include/sys/param.h \
+ ../../include/sys/time.h ../../include/time.h \
+ ../../include/sys/resource.h
+get_put.s get_put.o: get_put.c ../../include/viz/math_emu.h \
+ ../../include/viz/sched.h ../../include/viz/head.h \
+ ../../include/viz/fs.h ../../include/sys/types.h \
+ ../../include/viz/mm.h ../../include/viz/kernel.h \
+ ../../include/signal.h ../../include/sys/param.h \
+ ../../include/sys/time.h ../../include/time.h \
+ ../../include/sys/resource.h ../../include/asm/segment.h
+math_emulate.s math_emulate.o: math_emulate.c ../../include/viz/math_emu.h \
+ ../../include/viz/sched.h ../../include/viz/head.h \
+ ../../include/viz/fs.h ../../include/sys/types.h \
+ ../../include/viz/mm.h ../../include/viz/kernel.h \
+ ../../include/signal.h ../../include/sys/param.h \
+ ../../include/sys/time.h ../../include/time.h \
+ ../../include/sys/resource.h ../../include/asm/segment.h
+mul.s mul.o: mul.c ../../include/viz/math_emu.h ../../include/viz/sched.h \
+ ../../include/viz/head.h ../../include/viz/fs.h \
+ ../../include/sys/types.h ../../include/viz/mm.h \
+ ../../include/viz/kernel.h ../../include/signal.h \
+ ../../include/sys/param.h ../../include/sys/time.h ../../include/time.h \
+ ../../include/sys/resource.h
diff --git a/kernel/sys_call.s b/kernel/sys_call.s
index 84e6ee5..c4a51eb 100755
--- a/kernel/sys_call.s
+++ b/kernel/sys_call.s
@@ -99,13 +99,13 @@ _system_call:
 	call _sys_call_table(,%eax,4)
 	pushl %eax
 2:
-	movl _current,%eax
+	movl current,%eax
 	cmpl $0,state(%eax)		# state
 	jne reschedule
 	cmpl $0,counter(%eax)		# counter
 	je reschedule
 ret_from_sys_call:
-	movl _current,%eax
+	movl current,%eax
 	cmpl _task,%eax			# task[0] cannot have signals
 	je 3f
 	cmpw $0x0f,CS(%esp)		# was old code segment supervisor ?
diff --git a/lib/Makefile b/lib/Makefile
index 16479fe..516f154 100755
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -1,73 +1,77 @@
-#
-# Makefile for some libs needed in the kernel.
-#
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
-
-AR	=gar
-AS	=gas
-LD	=gld
-LDFLAGS	=-s -x
-CC	=gcc
-CFLAGS	=-Wall -O -fstrength-reduce -fomit-frame-pointer -fcombine-regs \
-	-finline-functions -mstring-insns -nostdinc -I../include
-CPP	=gcc -E -nostdinc -I../include
-
-.c.s:
-	$(CC) $(CFLAGS) \
-	-S -o $*.s $<
-.s.o:
-	$(AS) -c -o $*.o $<
-.c.o:
-	$(CC) $(CFLAGS) \
-	-c -o $*.o $<
-
-OBJS  = ctype.o _exit.o open.o close.o errno.o write.o dup.o setsid.o \
-	execve.o wait.o string.o malloc.o
-
-lib.a: $(OBJS)
-	$(AR) rcs lib.a $(OBJS)
-	sync
-
-clean:
-	rm -f core *.o *.a tmp_make
-	for i in *.c;do rm -f `basename $$i .c`.s;done
-
-dep:
-	sed '/\#\#\# Dependencies/q' < Makefile > tmp_make
-	(for i in *.c;do echo -n `echo $$i | sed 's,\.c,\.s,'`" "; \
-		$(CPP) -M $$i;done) >> tmp_make
-	cp tmp_make Makefile
-
-### Dependencies:
-_exit.s _exit.o : _exit.c ../include/unistd.h ../include/sys/stat.h \
-  ../include/sys/types.h ../include/sys/times.h ../include/sys/utsname.h \
-  ../include/utime.h 
-close.s close.o : close.c ../include/unistd.h ../include/sys/stat.h \
-  ../include/sys/types.h ../include/sys/times.h ../include/sys/utsname.h \
-  ../include/utime.h 
-ctype.s ctype.o : ctype.c ../include/ctype.h 
-dup.s dup.o : dup.c ../include/unistd.h ../include/sys/stat.h \
-  ../include/sys/types.h ../include/sys/times.h ../include/sys/utsname.h \
-  ../include/utime.h 
-errno.s errno.o : errno.c 
-execve.s execve.o : execve.c ../include/unistd.h ../include/sys/stat.h \
-  ../include/sys/types.h ../include/sys/times.h ../include/sys/utsname.h \
-  ../include/utime.h 
-malloc.s malloc.o : malloc.c ../include/viz/kernel.h ../include/viz/mm.h \
-  ../include/asm/system.h 
-open.s open.o : open.c ../include/unistd.h ../include/sys/stat.h \
-  ../include/sys/types.h ../include/sys/times.h ../include/sys/utsname.h \
-  ../include/utime.h ../include/stdarg.h 
-setsid.s setsid.o : setsid.c ../include/unistd.h ../include/sys/stat.h \
-  ../include/sys/types.h ../include/sys/times.h ../include/sys/utsname.h \
-  ../include/utime.h 
-string.s string.o : string.c ../include/string.h 
-wait.s wait.o : wait.c ../include/unistd.h ../include/sys/stat.h \
-  ../include/sys/types.h ../include/sys/times.h ../include/sys/utsname.h \
-  ../include/utime.h ../include/sys/wait.h 
-write.s write.o : write.c ../include/unistd.h ../include/sys/stat.h \
-  ../include/sys/types.h ../include/sys/times.h ../include/sys/utsname.h \
-  ../include/utime.h 
+#
+# Makefile for some libs needed in the kernel.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+include ../Makefile.header
+
+CFLAGS	+= -finline-functions -nostdinc -I../include
+CPP	+= -I../include
+
+.c.s:
+	@$(CC) $(CFLAGS) \
+	-S -o $*.s $<
+.s.o:
+	@$(AS) -o $*.o $<
+.c.o:
+	@$(CC) $(CFLAGS) \
+	-c -o $*.o $<
+
+OBJS   = ctype.o _exit.o open.o close.o errno.o write.o dup.o setsid.o \
+	execve.o wait.o string.o malloc.o debug.o
+lib.a: $(OBJS)
+	@$(AR) rcs lib.a $(OBJS)
+	@sync
+
+clean:
+	@rm -f core *.o *.a tmp_make
+	@for i in *.c;do rm -f `basename $$i .c`.s;done
+
+dep:
+	@sed '/\#\#\# Dependencies/q' < Makefile > tmp_make
+	@(for i in *.c;do echo -n `echo $$i | sed 's,\.c,\.s,'`" "; \
+		$(CPP) -M $$i;done) >> tmp_make
+	@cp tmp_make Makefile
+
+### Dependencies:
+_exit.s _exit.o: _exit.c ../include/unistd.h ../include/sys/stat.h \
+ ../include/sys/types.h ../include/sys/time.h ../include/time.h \
+ ../include/sys/times.h ../include/sys/utsname.h ../include/sys/param.h \
+ ../include/sys/resource.h ../include/utime.h
+close.s close.o: close.c ../include/unistd.h ../include/sys/stat.h \
+ ../include/sys/types.h ../include/sys/time.h ../include/time.h \
+ ../include/sys/times.h ../include/sys/utsname.h ../include/sys/param.h \
+ ../include/sys/resource.h ../include/utime.h
+ctype.s ctype.o: ctype.c ../include/ctype.h
+debug.s debug.o: debug.c ../include/stdarg.h ../include/viz/kernel.h
+dup.s dup.o: dup.c ../include/unistd.h ../include/sys/stat.h \
+ ../include/sys/types.h ../include/sys/time.h ../include/time.h \
+ ../include/sys/times.h ../include/sys/utsname.h ../include/sys/param.h \
+ ../include/sys/resource.h ../include/utime.h
+errno.s errno.o: errno.c
+execve.s execve.o: execve.c ../include/unistd.h ../include/sys/stat.h \
+ ../include/sys/types.h ../include/sys/time.h ../include/time.h \
+ ../include/sys/times.h ../include/sys/utsname.h ../include/sys/param.h \
+ ../include/sys/resource.h ../include/utime.h
+malloc.s malloc.o: malloc.c ../include/viz/kernel.h ../include/viz/mm.h \
+ ../include/signal.h ../include/sys/types.h ../include/asm/system.h
+open.s open.o: open.c ../include/unistd.h ../include/sys/stat.h \
+ ../include/sys/types.h ../include/sys/time.h ../include/time.h \
+ ../include/sys/times.h ../include/sys/utsname.h ../include/sys/param.h \
+ ../include/sys/resource.h ../include/utime.h ../include/stdarg.h
+setsid.s setsid.o: setsid.c ../include/unistd.h ../include/sys/stat.h \
+ ../include/sys/types.h ../include/sys/time.h ../include/time.h \
+ ../include/sys/times.h ../include/sys/utsname.h ../include/sys/param.h \
+ ../include/sys/resource.h ../include/utime.h
+string.s string.o: string.c ../include/string.h
+wait.s wait.o: wait.c ../include/unistd.h ../include/sys/stat.h \
+ ../include/sys/types.h ../include/sys/time.h ../include/time.h \
+ ../include/sys/times.h ../include/sys/utsname.h ../include/sys/param.h \
+ ../include/sys/resource.h ../include/utime.h ../include/sys/wait.h
+write.s write.o: write.c ../include/unistd.h ../include/sys/stat.h \
+ ../include/sys/types.h ../include/sys/time.h ../include/time.h \
+ ../include/sys/times.h ../include/sys/utsname.h ../include/sys/param.h \
+ ../include/sys/resource.h ../include/utime.h
diff --git a/lib/malloc.c b/lib/malloc.c
index 4b3c68a..1b6f35f 100755
--- a/lib/malloc.c
+++ b/lib/malloc.c
@@ -153,7 +153,7 @@ void *malloc(unsigned int len)
 		free_bucket_desc = bdesc->next;
 		bdesc->refcnt = 0;
 		bdesc->bucket_size = bdir->size;
-		bdesc->page = bdesc->freeptr = (void *) cp = get_free_page();
+		bdesc->page = bdesc->freeptr = (void *)(cp = (char*)get_free_page());
 		if (!cp)
 			panic("Out of memory in kernel malloc()");
 		/* Set up the chain of free objects */
diff --git a/mm/Makefile b/mm/Makefile
index 46c2826..17a6a03 100755
--- a/mm/Makefile
+++ b/mm/Makefile
@@ -1,44 +1,43 @@
-CC	=gcc
-CFLAGS	=-O -Wall -fstrength-reduce -fcombine-regs -fomit-frame-pointer \
-	-finline-functions -nostdinc -I../include
-AS	=gas
-AR	=gar
-LD	=gld
-CPP	=gcc -E -nostdinc -I../include
-
-.c.o:
-	$(CC) $(CFLAGS) \
-	-c -o $*.o $<
-.s.o:
-	$(AS) -o $*.o $<
-.c.s:
-	$(CC) $(CFLAGS) \
-	-S -o $*.s $<
-
-OBJS	= memory.o swap.o page.o
-
-all: mm.o
-
-mm.o: $(OBJS)
-	$(LD) -r -o mm.o $(OBJS)
-
-clean:
-	rm -f core *.o *.a tmp_make
-	for i in *.c;do rm -f `basename $$i .c`.s;done
-
-dep:
-	sed '/\#\#\# Dependencies/q' < Makefile > tmp_make
-	(for i in *.c;do $(CPP) -M $$i;done) >> tmp_make
-	cp tmp_make Makefile
-
-### Dependencies:
-memory.o : memory.c ../include/signal.h ../include/sys/types.h \
-  ../include/asm/system.h ../include/viz/sched.h ../include/viz/head.h \
-  ../include/viz/fs.h ../include/viz/mm.h ../include/viz/kernel.h \
-  ../include/sys/param.h ../include/sys/time.h ../include/time.h \
-  ../include/sys/resource.h 
-swap.o : swap.c ../include/string.h ../include/viz/sched.h \
-  ../include/viz/head.h ../include/viz/fs.h ../include/sys/types.h \
-  ../include/viz/mm.h ../include/viz/kernel.h ../include/signal.h \
-  ../include/sys/param.h ../include/sys/time.h ../include/time.h \
-  ../include/sys/resource.h 
+
+include ../Makefile.header
+
+LDFLAGS += -r
+CFLAGS	+= -finline-functions -nostdinc -I../include
+CPP	+= -I../include
+
+.c.o:
+	@$(CC) $(CFLAGS) \
+	-c -o $*.o $<
+.s.o:
+	@$(AS) -o $*.o $<
+.c.s:
+	@$(CC) $(CFLAGS) \
+	-S -o $*.s $<
+
+OBJS	= memory.o swap.o page.o
+
+all: mm.o
+
+mm.o: $(OBJS)
+	@$(LD) $(LDFLAGS) -o mm.o $(OBJS)
+
+clean:
+	@rm -f core *.o *.a tmp_make
+	@for i in *.c;do rm -f `basename $$i .c`.s;done
+
+dep:
+	@sed '/\#\#\# Dependencies/q' < Makefile > tmp_make
+	@(for i in *.c;do $(CPP) -M $$i;done) >> tmp_make
+	@cp tmp_make Makefile
+
+### Dependencies:
+memory.o: memory.c ../include/signal.h ../include/sys/types.h \
+ ../include/asm/system.h ../include/linux/sched.h ../include/linux/head.h \
+ ../include/linux/fs.h ../include/linux/mm.h ../include/linux/kernel.h \
+ ../include/sys/param.h ../include/sys/time.h ../include/time.h \
+ ../include/sys/resource.h
+swap.o: swap.c ../include/string.h ../include/linux/mm.h \
+ ../include/linux/kernel.h ../include/signal.h ../include/sys/types.h \
+ ../include/linux/sched.h ../include/linux/head.h ../include/linux/fs.h \
+ ../include/sys/param.h ../include/sys/time.h ../include/time.h \
+ ../include/sys/resource.h
diff --git a/mm/memory.c b/mm/memory.c
index 43d22de..c378112 100755
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -42,7 +42,7 @@ current->start_code + current->end_code)
 unsigned long HIGH_MEMORY = 0;
 
 #define copy_page(from,to) \
-__asm__("cld ; rep ; movsl"::"S" (from),"D" (to),"c" (1024):"cx","di","si")
+__asm__("cld ; rep ; movsl"::"S" (from),"D" (to),"c" (1024):)
 
 unsigned char mem_map [ PAGING_PAGES ] = {0,};
 
diff --git a/mm/swap.c b/mm/swap.c
index eacbb70..32d6305 100755
--- a/mm/swap.c
+++ b/mm/swap.c
@@ -188,7 +188,7 @@ repeat:
 		:"=a" (__res)
 		:"0" (0),"i" (LOW_MEM),"c" (PAGING_PAGES),
 		"D" (mem_map+PAGING_PAGES-1)
-		:"di","cx","dx");
+		:"dx");
 	if (__res >= HIGH_MEMORY)
 		goto repeat;
 	if (!__res && swap_out())
